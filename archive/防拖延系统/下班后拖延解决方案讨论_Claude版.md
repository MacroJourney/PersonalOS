我问：
Timing 有一个功能，就是当我离开电脑一段时间之后，再回来操作电脑，就会弹出一个框让我填写离开这段时间去干嘛了。这个功能是如何实现的？
AI 回答：
Timing 的"离开电脑后填写时间"功能主要通过以下技术实现：

## 核心原理

**空闲时间检测（Idle Time Detection）** - 通过监控键盘和鼠标的活动状态来判断用户是否在使用电脑。当检测到一段时间内没有任何键盘输入或鼠标移动时，系统会将这段时间标记为"空闲时间"。[^1]

## 技术实现方式

在 macOS 系统中，可以通过系统 API 获取空闲时间。具体实现是使用 `IOHIDSystem` 来查询 `HIDIdleTime` 参数，这个值记录了自上次键盘或鼠标活动以来经过的时间：

```
ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}'
``` [^2]

## 工作流程

1. **后台监控** - Timing 在后台持续监控键盘和鼠标活动
2. **阈值触发** - 当空闲时间超过设定的阈值（默认 3 分钟，可在设置中调整），系统会记录这段时间
3. **返回提示** - 当你重新开始使用电脑时（检测到键盘或鼠标活动），Timing 会在菜单栏弹出提示框
4. **手动分配** - 你可以选择将这段离开时间分配到某个项目分类，或者在"总览"页面手动处理 [^3] [^4]

## 关键设置

在 Timing 的"Tracking"偏好设置中，可以配置空闲时间检测的行为，包括：
* 设置空闲时间阈值
* 选择检测到空闲后是否停止正在运行的计时器
* 决定是否要求用户记录离开时做了什么 [^1]

这种机制确保了即使你离开电脑去开会、打电话或做其他事情，这些时间也不会丢失，可以被准确记录和归类到相应的工作项目中。

[^1]: https://timingapp.com/help/preferences
[^2]: https://dev59.com/L3XYa4cB1Zd3GeqP2RzJ
[^3]: https://sspai.com/post/45783
[^4]: https://www.imacso.com/timing.html

我问：
背景：我的Mac mini 一般是 7*24 小时处于开机状态，工作日早上我去上班了，电脑也一直开着，然后下班回来之后，我一般会开始使用电脑。但是由于我是拖延症患者，我一直想要下班后回来开始学习或做其他有意义的事情，而不是沉迷于追剧或者玩游戏。
我想使用上面这个技术方案或者类似的技术方案也行，实现一个功能，就是我下班回来开始使用电脑之后，提示引导我开始学习，而不是沉迷于追剧等其他无意义的事情。

AI 回答：
这是一个很有意义的需求！基于 Timing 的空闲检测原理，我可以给你几个技术实现方案：

## 方案一：AppleScript + Launchd（最简单）

创建一个 AppleScript 应用，持续监控空闲状态，在检测到"长时间空闲后重新激活"时触发提示。

**实现步骤：**

1. **创建 AppleScript**（保存为应用程序，勾选"运行处理程序后保持打开"）

```applescript
global idleThreshold, wasIdle, workHoursEnd, workHoursStart

on run
    -- 设置空闲阈值（秒），例如8小时 = 28800秒
    set idleThreshold to 28800
    set wasIdle to false
    -- 设置工作时间（24小时制）
    set workHoursEnd to 18 -- 下午6点
    set workHoursStart to 9 -- 早上9点
end run

on idle
    set currentIdleTime to (do shell script "ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}'") as number
    set currentHour to (hours of (current date))
    
    -- 如果当前空闲时间超过阈值，标记为空闲状态
    if currentIdleTime ≥ idleThreshold then
        set wasIdle to true
    end if
    
    -- 如果之前是空闲状态，现在重新激活（空闲时间小于60秒）
    if wasIdle and currentIdleTime < 60 then
        set wasIdle to false
        
        -- 只在下班时间（18:00-23:00）触发提示
        if currentHour ≥ workHoursEnd and currentHour < 23 then
            -- 显示全屏提醒对话框
            display dialog "🎯 欢迎回来！

现在是学习的好时机，你今晚想要：

✅ 开始学习新技能
✅ 完成重要项目
✅ 提升自己

而不是沉迷娱乐，浪费宝贵时间。

你准备好开始了吗？" buttons {"我需要休息", "开始学习！"} default button 2 with icon caution giving up after 30
            
            set userChoice to button returned of result
            
            if userChoice is "开始学习！" then
                -- 可以在这里打开学习相关的应用
                -- tell application "Notion" to activate
                -- 或者打开特定网站
                do shell script "open https://你的学习网站.com"
            end if
        end if
    end if
    
    -- 每30秒检查一次
    return 30
end idle
```

2. **设置为登录时自动启动**
   - 系统设置 → 通用 → 登录项 → 添加这个应用

---

## 方案二：Python 脚本（更灵活）

使用 Python 实现更强大的功能，可以添加更多智能判断。

```python
#!/usr/bin/env python3
import subprocess
import time
from datetime import datetime
import os

class FocusReminder:
    def __init__(self):
        self.idle_threshold = 8 * 60 * 60  # 8小时，单位：秒
        self.was_idle = False
        self.work_hours_end = 18  # 下午6点
        self.check_interval = 30  # 每30秒检查一次
        
    def get_idle_time(self):
        """获取系统空闲时间（秒）"""
        cmd = "ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}'"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return float(result.stdout.strip())
    
    def is_work_evening(self):
        """判断是否是工作日晚上"""
        now = datetime.now()
        # 周一到周五
        is_weekday = now.weekday() < 5
        # 18:00-23:00
        is_evening = self.work_hours_end <= now.hour < 23
        return is_weekday and is_evening
    
    def show_reminder(self):
        """显示提醒对话框"""
        script = '''
        display dialog "🎯 专注时刻到了！

你已经离开电脑很久了，现在是学习的黄金时间。

今晚的目标是什么？
• 学习新技能
• 完成重要项目  
• 阅读或写作

选择你的行动：" buttons {"稍后提醒", "查看今日目标", "立即开始！"} default button 3 with icon note
        '''
        
        result = subprocess.run(['osascript', '-e', script], 
                              capture_output=True, text=True)
        
        if "立即开始！" in result.stdout:
            self.open_focus_apps()
        elif "查看今日目标" in result.stdout:
            self.open_todo_list()
    
    def open_focus_apps(self):
        """打开学习相关的应用"""
        # 根据你的需求修改
        apps_to_open = [
            # "Notion",
            # "VS Code",
            # "Obsidian",
        ]
        for app in apps_to_open:
            os.system(f'open -a "{app}"')
    
    def open_todo_list(self):
        """打开待办事项"""
        # 可以打开你的任务管理工具
        os.system('open -a "Reminders"')
    
    def block_distractions(self):
        """可选：屏蔽干扰网站"""
        # 可以集成 Focus、Cold Turkey 等应用的 CLI
        pass
    
    def run(self):
        """主循环"""
        print("Focus Reminder 已启动...")
        print(f"空闲阈值: {self.idle_threshold/3600}小时")
        
        while True:
            try:
                idle_time = self.get_idle_time()
                
                # 标记空闲状态
                if idle_time >= self.idle_threshold:
                    self.was_idle = True
                    print(f"检测到长时间空闲: {idle_time/3600:.2f}小时")
                
                # 检测重新激活
                if self.was_idle and idle_time < 60:
                    print("检测到重新激活电脑")
                    self.was_idle = False
                    
                    # 只在工作日晚上触发
                    if self.is_work_evening():
                        print("触发学习提醒...")
                        self.show_reminder()
                    else:
                        print("非工作日晚上，跳过提醒")
                
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                print("\n程序已停止")
                break
            except Exception as e:
                print(f"错误: {e}")
                time.sleep(self.check_interval)

if __name__ == "__main__":
    reminder = FocusReminder()
    reminder.run()
```

**使用方法：**

1. 保存为 `focus_reminder.py`
2. 添加执行权限：`chmod +x focus_reminder.py`
3. 创建 launchd 配置让它开机自启

创建 `~/Library/LaunchAgents/com.focusreminder.plist`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.focusreminder</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/python3</string>
        <string>/Users/你的用户名/focus_reminder.py</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
```

加载服务：
```bash
launchctl load ~/Library/LaunchAgents/com.focusreminder.plist
```

---

## 方案三：使用现成工具组合

如果不想写代码，可以组合使用现有工具：

1. **Hammerspoon**（Lua 脚本自动化工具）
   - 免费且强大的 macOS 自动化工具
   - 可以监控空闲时间并触发动作

2. **Keyboard Maestro** + **Focus/Cold Turkey**
   - Keyboard Maestro 检测空闲恢复
   - 自动启动专注模式，屏蔽干扰网站

3. **Shortcuts（快捷指令）** + **个人自动化**
   - 结合系统的屏幕时间功能
   - 创建自动化流程

---

## 推荐的增强功能

1. **智能判断**：
   - 识别工作日 vs 周末
   - 区分不同时间段（早晨、下午、晚上）
   - 记录你的学习习惯，在最佳时间提醒

2. **渐进式提醒**：
   - 第一次温和提醒
   - 如果继续娱乐，逐渐增强提醒强度

3. **数据跟踪**：
   - 记录每次的选择
   - 生成每周学习报告
   - 可视化你的进步

4. **激励机制**：
   - 连续学习天数打卡
   - 设置学习目标和奖励

你觉得哪个方案更适合你？我可以帮你进一步完善具体的实现细节。

我问：
我们先来讨论需求吧。你来问我问题，我来回答，形成一份用户旅程，然后再根据用户流程形成一份 PRD。我现在想到的就是，要有一个可视化的界面，然后激活以后要弹出一个全屏的界面且不能关闭。

AI 回答：
好的！我来通过提问帮你梳理清楚整个需求。让我们一步步来：

## 第一部分：触发条件

**Q1: 空闲时间阈值**
- 你希望电脑空闲多久后，才算是"你离开了电脑"？
  - 比如：6小时？8小时？还是可以自定义？

**Q2: 激活检测时间**
- 当你重新使用电脑后，多快触发提醒？
  - 立即触发？还是等待一段时间（比如活动超过30秒后）？

**Q3: 触发时间段限制**
- 你只想在特定时间段触发吗？
  - 工作日晚上（比如18:00-23:00）？
  - 还是包括周末？
  - 早上需要触发吗？

**Q4: 重复触发**
- 如果你选择了"稍后"或关闭提醒后，继续娱乐了一段时间，需要再次提醒吗？
  - 如果需要，间隔多久？（比如30分钟后再提醒）

---

## 第二部分：全屏界面内容

**Q5: 界面要展示什么信息？**
你提到要全屏且不能关闭，那么界面上应该显示：
- 一段激励文字/问候语？
- 今天的日期和时间？
- 你离开电脑的时长统计？
- 今日学习目标/待办事项？
- 其他什么？

**Q6: 用户必须做出选择吗？**
既然不能关闭，用户需要通过什么方式才能继续使用电脑？
- 必须选择一个"今晚要做的事情"？
- 必须输入今晚的学习目标？
- 还是其他形式的"承诺"？

**Q7: 具体有哪些选项？**
你希望给自己提供哪些选择？比如：
- ✅ 开始学习（然后进入专注模式）
- 📝 查看/设置今日目标
- 🎯 快速开始某个具体项目
- ⏰ 我需要休息15分钟
- 🎮 我就是要娱乐（需要额外确认？）

---

## 第三部分：选择后的行为

**Q8: 选择"开始学习"后要做什么？**
- 自动打开特定应用（比如VS Code、Notion、Obsidian）？
- 启动专注模式（屏蔽娱乐网站/应用）？
- 启动计时器追踪学习时间？
- 播放专注音乐？

**Q9: 专注模式的具体内容**
如果选择学习，是否要：
- 屏蔽特定网站（YouTube、Netflix、B站等）？
- 禁用特定应用（游戏、视频播放器）？
- 持续时间多久？（比如默认25分钟一个番茄钟）
- 能否中途退出？需要什么条件？

**Q10: 选择"休息/娱乐"后**
- 需要设置一个休息时长吗？（比如15/30/60分钟）
- 时间到了后再次提醒？
- 还是完全放开，不再管控？

---

## 第四部分：数据记录与反馈

**Q11: 需要记录什么数据？**
- 每次的选择（学习/休息/娱乐）？
- 实际学习时长？
- 连续学习天数？
- 每周学习总时长？

**Q12: 数据展示方式**
- 需要一个统计面板吗？
- 每天/每周生成报告？
- 显示进度条、成就徽章等激励元素？

**Q13: 目标设置**
- 需要设定学习目标吗？（比如每天学习2小时）
- 未完成目标时有提醒吗？
- 完成目标有庆祝动画或提示吗？

---

## 第五部分：配置与设置

**Q14: 可配置项**
你希望能自定义哪些内容？
- 空闲时间阈值
- 触发时间段
- 屏蔽的网站/应用列表
- 激励语/提醒文案
- 专注时长
- 提醒频率

**Q15: 配置界面**
- 需要一个独立的设置面板吗？
- 还是通过配置文件修改？
- 是否需要菜单栏图标方便快速访问？

---

## 第六部分：特殊场景

**Q16: 紧急退出**
虽然全屏不可关闭，但遇到紧急情况怎么办？
- 是否需要一个"隐藏的退出方式"？（比如特定快捷键组合）
- 还是完全不允许关闭？

**Q17: 系统重启**
如果你重启电脑，程序如何处理？
- 记住之前的状态？
- 重新开始判断？

**Q18: 误触发处理**
如果你只是短暂使用电脑（比如查看一条消息），不想被打断怎么办？
- 需要延迟触发机制吗？
- 还是每次都弹出？

---

请你先回答这些问题，我会根据你的回答整理出完整的用户旅程和PRD文档！你可以分几次回答，不用一次全部答完。

我问：
Q1：可以自定义
Q2：也是自定义，默认是立即触发
Q3：我现阶段的需求是工作日晚上
Q4：需要再次提醒，间隔多久：自定义
Q5：一段激励文字/问候语，今天的日期和时间，今日学习目标/待办事项，可以集成 Mac 系统的提醒事项和日历，后续考虑集成其他的待办应用和日历应用
Q6：必须选择或者输入“今晚要做的事情”，当然也可以选择稍后提醒，但是必须要有一个限制时间，限制时间到了之后再次提醒。并且选择稍后提醒的话，必须要有理由，为什么要稍后提醒，选择稍后提醒这段时间你要做什么事情？为什么要做这件事情？反正就是要设置重重阻碍
Q7：查看/设置今日目标、快速开始某个具体项目。我需要休息 15 分钟或者我就是要娱乐可以提供选择，但是就像 Q6 我说的，要设置重重阻碍。
Q8：暂时不做什么，作为后续扩展
Q9：暂时不做什么，作为后续扩展
Q10：需要设置一个休息时长、时间到了后再次提醒
Q11：每次的选择，其他的还没想好，也不是都是要学习，也可以是做什么具体的项目
Q12：需要统计面板、每天/每周生成报告，但是报告的内容还没想好。显示进度条、成就徽章等激励元素可以作为后续扩展
Q13：感觉需要有目标设置，但是时长要如何检测呢？比如说选择了要学习（假设有学习），但实际却是去干别的了，这怎么办？
Q14：空闲时间阈值、触发时间段、屏蔽的网站/应用列表、激励语/提醒文案、专注时长、提醒频率
Q15：需要有独立的设置面板，配置文件修改和菜单栏快速方案作为后续扩展
Q16：需要一个“隐藏的退出方式”
Q17：重新开始判断
Q18：需要延迟触发机制

AI 回答：
非常好！你的回答很详细。现在让我基于你的回答整理出完整的用户旅程和PRD文档。

---

# 用户旅程地图 (User Journey Map)

## 场景：工作日晚上回家后激活电脑

### 阶段 1：离开电脑（上班时段）
**用户行为：**
- 早上去上班，Mac mini 保持开机状态
- 电脑空闲时长开始累积

**系统行为：**
- 后台监控键盘/鼠标活动
- 记录空闲时长
- 当空闲时长 > 自定义阈值（默认8小时），标记为"长时间离开"状态

**用户情绪：** 😐 中性

---

### 阶段 2：下班回家，接近电脑
**用户行为：**
- 下班回到家（18:00-23:00 工作日晚上时段）
- 准备使用电脑

**系统行为：**
- 等待用户交互

**用户情绪：** 😊 期待使用电脑

---

### 阶段 3：初次接触电脑（延迟触发检测）
**用户行为：**
- 移动鼠标或按下键盘

**系统行为：**
- 检测到用户活动
- **启动延迟触发计时器**（默认立即触发，可自定义如30秒）
- 判断：
  - ✅ 当前时间在工作日晚上（18:00-23:00）
  - ✅ 之前空闲时长 > 阈值
  - ✅ 用户持续活动 > 延迟触发时长
  - → **触发全屏界面**

**用户情绪：** 😯 被打断但预期之中

---

### 阶段 4：全屏界面出现 🎯

**界面布局：**
```
┌─────────────────────────────────────────────────────────────┐
│                     🌟 欢迎回来！现在是专注时刻 🌟                    │
│                                                             │
│                  📅 2026年1月23日 星期四 19:30               │
│                  ⏰ 你已经离开电脑 9小时32分钟                  │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  💡 今日激励：                                               │
│  "每一次选择都在塑造未来的你。今晚，选择成为更好的自己。"          │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  📝 今日目标与待办：                                          │
│  □ 完成 Python 项目第三章（来自提醒事项）                       │
│  □ 21:00 线上读书会（来自日历）                               │
│  □ 学习 SwiftUI 1小时                                        │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│           今晚你打算做什么？（必选）                            │
│                                                             │
│  [📋 查看/设置今日目标]  [🚀 快速开始具体项目]                   │
│                                                             │
│            还没准备好？                                        │
│  [⏰ 稍后提醒（需说明理由）]                                    │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**系统行为：**
- 全屏覆盖，无法点击其他区域
- 禁用 Cmd+Q、Cmd+W 等常规退出快捷键
- 隐藏退出方式：Cmd+Option+Control+Shift+E（应急使用）

**用户情绪：** 🤔 需要思考和决策

---

### 阶段 5A：用户选择"📋 查看/设置今日目标"

**用户行为：**
- 点击"查看/设置今日目标"

**系统行为：**
- 在当前全屏界面展开目标设置表单

**界面变化：**
```
┌─────────────────────────────────────────────────────────────┐
│                     设置今晚目标                              │
│                                                             │
│  目标标题：                                                   │
│  [_________________________________________________]        │
│                                                             │
│  预计时长：                                                   │
│  [ 30分钟 ▼ ]  [ 1小时 ▼ ]  [ 2小时 ▼ ]  [自定义___分钟]     │
│                                                             │
│  目标类型：                                                   │
│  ( ) 学习  ( ) 项目  ( ) 阅读  ( ) 写作  ( ) 其他            │
│                                                             │
│  具体描述（可选）：                                            │
│  [_________________________________________________]        │
│  [_________________________________________________]        │
│                                                             │
│              [取消]        [保存并开始]                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**后续流程：**
- 用户填写完成 → 点击"保存并开始" → **关闭全屏界面，进入正常使用**
- 系统开始追踪这个目标的时间（可选功能，后续扩展）

**用户情绪：** 💪 明确目标，有动力

---

### 阶段 5B：用户选择"🚀 快速开始具体项目"

**用户行为：**
- 点击"快速开始具体项目"

**系统行为：**
- 显示最近的项目列表（从历史记录中读取）

**界面变化：**
```
┌─────────────────────────────────────────────────────────────┐
│                   选择要继续的项目                             │
│                                                             │
│  最近项目：                                                   │
│  ┌─────────────────────────────────────────────┐            │
│  │ 🐍 Python 自动化脚本开发  [继续]              │            │
│  │    上次工作：昨天 21:30  累计：5小时30分       │            │
│  └─────────────────────────────────────────────┘            │
│                                                             │
│  ┌─────────────────────────────────────────────┐            │
│  │ 📱 SwiftUI 学习  [继续]                      │            │
│  │    上次工作：3天前  累计：2小时15分            │            │
│  └─────────────────────────────────────────────┘            │
│                                                             │
│  ┌─────────────────────────────────────────────┐            │
│  │ ✏️ 博客文章写作  [继续]                       │            │
│  │    上次工作：1周前  累计：3小时45分            │            │
│  └─────────────────────────────────────────────┘            │
│                                                             │
│              [返回]        [+ 新建项目]                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**后续流程：**
- 点击某个项目 → **关闭全屏界面，开始追踪该项目时间**
- 点击"新建项目" → 跳转到类似 5A 的创建界面

**用户情绪：** 🎯 清晰，快速进入状态

---

### 阶段 5C：用户选择"⏰ 稍后提醒"（重重阻碍）

**用户行为：**
- 点击"稍后提醒"

**系统行为：**
- 弹出"阻碍层级1"

**界面变化：**
```
┌─────────────────────────────────────────────────────────────┐
│                   ⚠️ 真的要稍后吗？                            │
│                                                             │
│  选择稍后意味着推迟你的成长和进步。                             │
│                                                             │
│  请告诉我你的理由：                                            │
│                                                             │
│  稍后这段时间我需要：                                          │
│  [_________________________________________________]        │
│                                                             │
│  这件事为什么必须现在做？                                      │
│  [_________________________________________________]        │
│  [_________________________________________________]        │
│                                                             │
│  推迟多久？                                                   │
│  ( ) 15分钟  ( ) 30分钟  ( ) 1小时  ( ) 自定义___分钟         │
│                                                             │
│  ⚠️ 注意：选择稍后后，这段时间将被记录为"拖延时间"                │
│                                                             │
│              [我想清楚了，开始工作]   [确认稍后]               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**条件判断：**
- 如果用户点击"我想清楚了，开始工作" → 返回主界面（阶段4）
- 如果用户填写理由 < 10个字 → 提示"请认真思考并详细说明理由"
- 如果理由合理且时长已选 → 点击"确认稍后" → **进入阻碍层级2**

**界面变化（阻碍层级2）：**
```
┌─────────────────────────────────────────────────────────────┐
│                   🤔 最后确认                                 │
│                                                             │
│  你即将推迟 30分钟，理由是：                                   │
│  "需要吃晚饭，还没来得及吃"                                    │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  💭 反思一下：                                                │
│                                                             │
│  • 这件事真的不能在工作后做吗？                                │
│  • 30分钟后你真的会开始工作，还是会继续拖延？                   │
│  • 今天已经是本周第 X 次选择"稍后提醒"了                       │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  请在下方输入"我确认稍后提醒"来继续：                           │
│  [_________________________________________________]        │
│                                                             │
│              [重新考虑]        [确认（输入后激活）]             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**后续流程：**
- 用户必须完整输入"我确认稍后提醒" → 按钮才激活
- 点击确认 → **关闭全屏界面**
- **系统记录：**
  - 拖延时间：30分钟
  - 拖延理由："需要吃晚饭"
  - 拖延次数 +1
- **30分钟后 → 再次弹出全屏界面（回到阶段4）**

**用户情绪：** 😰 感到压力，但可能仍然选择拖延 / 😤 被激励，改变主意

---

### 阶段 6：开始工作/学习

**用户行为：**
- 完成选择后，开始使用电脑进行学习/工作

**系统行为：**
- 全屏界面关闭
- 系统静默运行，追踪时间（如果用户选择了具体项目）
- 菜单栏显示图标，显示当前项目和已工作时长（可选）

**用户情绪：** 💪 专注，有目标感

---

### 阶段 7：中途检查（可选扩展功能）

**时间节点：**
- 用户工作一段时间后（如1小时）

**系统行为：**
- 发送轻量通知："已专注1小时，干得漂亮！💪"
- 不打断用户，仅作鼓励

---

### 阶段 8：完成或中断

**场景A：用户完成目标**
- 系统检测到目标时长已达到
- 发送祝贺通知："🎉 目标达成！今晚学习2小时完成！"
- 记录到统计数据

**场景B：用户中途离开**
- 检测到再次空闲 > X 分钟（可自定义）
- 记录实际工作时长
- 下次激活时询问："上次的任务完成了吗？"

**用户情绪：** 😊 成就感 / 😐 部分完成

---

### 阶段 9：查看统计报告

**用户行为：**
- 点击菜单栏图标 → "查看统计"
- 或在设置面板中查看

**界面展示：**
```
┌─────────────────────────────────────────────────────────────┐
│                   📊 本周统计报告                             │
│                                                             │
│  本周工作日晚上（共5天）：                                     │
│  ✅ 开始工作/学习：4次                                        │
│  ⏰ 选择稍后提醒：3次                                         │
│  📝 总工作时长：12小时30分钟                                  

我问：
继续

AI 回答：

```
│  📈 平均每天：2.5小时                                         │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  项目时间分布：                                               │
│  🐍 Python 开发      ████████░░  6小时15分  (50%)          │
│  📱 SwiftUI 学习     ████░░░░░░  3小时30分  (28%)          │
│  ✏️ 博客写作         ███░░░░░░░  2小时45分  (22%)          │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  拖延分析：                                                   │
│  • 本周选择"稍后提醒" 3次，累计拖延时长 1小时30分             │
│  • 最常见理由：吃饭(2次)、临时消息(1次)                        │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  🏆 成就：                                                   │
│  ✨ 连续工作 4 天                                            │
│  🔥 本周目标完成率：80%                                       │
│                                                             │
│            [导出报告]    [查看详细数据]    [关闭]             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**用户情绪：** 📊 清晰了解自己的进展，有数据支撑的成就感或反思

---

### 阶段 10：持续优化

**用户行为：**
- 根据统计数据调整行为
- 在设置中优化参数

**系统行为：**
- 学习用户习惯（后续扩展）
- 在合适时机发送激励

**用户情绪：** 🎯 持续改进

---

## 异常场景处理

### 异常 1：误触发（短暂使用）
**场景：** 用户只是查看一条消息就离开

**解决方案：** 延迟触发机制
- 用户活动 < 延迟时间（如30秒）→ 不触发
- 活动 > 延迟时间 → 才弹出全屏界面

### 异常 2：紧急情况需要立即使用电脑
**场景：** 接到紧急工作电话，需要立即操作电脑

**解决方案：** 隐藏退出方式
- 按 `Cmd+Option+Control+Shift+E` → 弹出确认对话框
- 输入"紧急情况"文本 → 才能关闭全屏界面
- 系统记录紧急退出次数（防止滥用）

### 异常 3：系统重启后
**场景：** 电脑重启或程序崩溃

**解决方案：**
- 程序启动时重新开始监控
- 不恢复之前的状态
- 清空"长时间离开"标记

### 异常 4：周末意外触发
**场景：** 虽然设置了只在工作日触发，但周末也可能长时间离开后返回

**解决方案：**
- 严格检查时间条件
- 周末不触发（按照用户设置）

---

---

# PRD 文档 (Product Requirements Document)

## 1. 产品概述

### 1.1 产品名称
**Focus Guardian**（专注守护者）

### 1.2 产品定位
一款帮助拖延症患者在下班后保持专注、养成良好学习习惯的 macOS 应用程序。通过智能检测用户空闲状态，在重新使用电脑时强制引导用户做出有意义的选择，减少娱乐拖延，提升个人成长效率。

### 1.3 目标用户
- **主要用户：** 有拖延症的职场人士，下班后想要学习提升但容易沉迷娱乐
- **使用场景：** 工作日晚上（18:00-23:00），长时间离开电脑后重新使用
- **痛点：** 
  - 容易忘记学习目标，习惯性打开娱乐应用
  - 缺乏自律，需要外部提醒和"强制"引导
  - 不知道自己的时间都花在哪里，缺少数据支持

### 1.4 核心价值
- **强制决策：** 全屏界面，必须做出选择才能继续使用电脑
- **重重阻碍：** 通过多层确认和理由填写，增加选择娱乐/拖延的心理成本
- **数据可视：** 清晰的统计报告，让用户看到自己的进步和拖延模式
- **灵活配置：** 多项参数可自定义，适应不同用户需求

---

## 2. 功能需求

### 2.1 核心功能（MVP 必需）

#### 2.1.1 空闲检测与触发
**功能描述：**
- 后台持续监控键盘和鼠标活动
- 当空闲时长超过阈值时，标记为"长时间离开"
- 用户重新激活电脑时，触发全屏提醒界面

**详细规格：**

| 参数 | 默认值 | 可配置范围 | 说明 |
|:---|:---|:---|:---|
| 空闲时间阈值 | 8小时 | 1-24小时 | 多久算"长时间离开" |
| 触发延迟时间 | 立即（0秒） | 0-300秒 | 用户活动多久后才触发界面 |
| 触发时间段 | 18:00-23:00 工作日 | 自定义时间段+星期 | 只在特定时间触发 |
| 重复提醒间隔 | 30分钟 | 5-120分钟 | 选择"稍后"后多久再次提醒 |

**技术实现：**
- 使用 `IOHIDSystem` 获取系统空闲时间
- 每30秒检查一次状态
- 使用 NSDate 判断当前时间和星期

#### 2.1.2 全屏引导界面
**功能描述：**
- 全屏覆盖，无法点击其他区域
- 展示激励文案、时间信息、今日目标
- 提供多个选择按钮

**界面元素：**

| 元素 | 必需/可选 | 说明 |
|:---|:---|:---|
| 欢迎标题 | 必需 | 如"欢迎回来！现在是专注时刻" |
| 日期时间 | 必需 | 当前日期和时间 |
| 离开时长 | 必需 | 显示空闲了多久 |
| 激励文案 | 必需 | 随机或按日期显示 |
| 今日目标列表 | 可选 | 从系统提醒事项和日历读取 |
| 操作按钮 | 必需 | 至少2个主要操作 |

**交互规则：**
- 禁用 Cmd+Q, Cmd+W, Cmd+H 等快捷键
- 禁用鼠标右键
- 禁用触控板手势（三指滑动、四指缩放）
- ESC 键无效
- 隐藏退出：`Cmd+Option+Control+Shift+E`

#### 2.1.3 目标设置与项目管理
**功能描述：**
用户可以创建、查看、选择今晚要完成的目标或项目

**目标属性：**

| 字段 | 类型 | 必需 | 说明 |
|:---|:---|:---|:---|
| 标题 | 文本 | ✅ | 目标名称 |
| 预计时长 | 数字 | ✅ | 30分钟/1小时/2小时/自定义 |
| 类型 | 枚举 | ✅ | 学习/项目/阅读/写作/其他 |
| 描述 | 文本 | ❌ | 可选的详细描述 |
| 创建时间 | 时间戳 | 自动 | 系统自动记录 |
| 状态 | 枚举 | 自动 | 进行中/已完成/已放弃 |

**项目列表：**
- 显示最近使用的3-5个项目
- 每个项目显示：名称、上次工作时间、累计时长
- 支持快速继续或新建项目

#### 2.1.4 "稍后提醒"阻碍机制
**功能描述：**
通过多层确认和理由填写，增加选择拖延的心理成本

**阻碍层级 1 - 理由说明：**

| 字段 | 验证规则 | 说明 |
|:---|:---|:---|
| 需要做什么 | 最少10个字 | 必须详细说明 |
| 为什么必须现在做 | 最少10个字 | 必须说明紧迫性 |
| 推迟时长 | 选择或输入 | 15/30/60分钟或自定义 |

**阻碍层级 2 - 最终确认：**
- 回显用户填写的理由
- 显示反思问题（3个引导性问题）
- 显示本周"稍后"次数统计
- 必须输入"我确认稍后提醒"才能激活确认按钮

**记录数据：**
- 拖延时间
- 拖延理由
- 拖延次数（每周/每月）

#### 2.1.5 系统集成（提醒事项和日历）
**功能描述：**
读取 macOS 系统的提醒事项和日历事件，展示在全屏界面

**提醒事项集成：**
- 使用 EventKit 框架读取
- 筛选条件：今天到期且未完成
- 显示格式：`□ 任务标题`
- 支持点击后打开系统提醒事项应用

**日历集成：**
- 读取今天和明天的事件
- 筛选：工作/学习相关日历（可配置）
- 显示格式：`□ HH:mm 事件标题`
- 支持点击后打开系统日历应用

**权限处理：**
- 首次运行时请求日历和提醒事项权限
- 如果用户拒绝，显示手动输入选项

#### 2.1.6 统计与报告
**功能描述：**
记录用户的选择和时间使用情况，生成可视化报告

**记录数据：**

| 数据项 | 记录时机 | 用途 |
|:---|:---|:---|
| 每次选择（开始工作/稍后提醒） | 用户做出选择时 | 统计工作vs拖延比例 |
| 选择理由（如果稍后） | 选择稍后时 | 分析拖延模式 |
| 项目/目标信息 | 开始工作时 | 时间分布分析 |
| 预计时长 vs 实际时长 | 结束时 | 目标完成率 |
| 触发时间 | 每次弹窗时 | 使用模式分析 |

**统计报告内容：**

**每日统计：**
- 今日是否触发
- 选择了什么
- 工作时长
- 目标完成情况

**每周报告：**
```
• 本周工作日晚上触发次数：X/5
• 开始工作次数：X
• 选择稍后次数：X
• 总工作时长：XX小时XX分钟
• 项目时间分布（饼图/柱状图）
• 拖延分析（次数、时长、常见理由）
• 连续工作天数
• 目标完成率
```

**可视化元素：**
- 进度条（时间分布）
- 柱状图（每日工作时长）
- 饼图（项目占比）
- 日历热力图（工作天数可视化）

#### 2.1.7 设置面板
**功能描述：**
独立的设置界面，允许用户自定义各项参数

**设置分类：**

**基础设置：**
```
┌─ 触发条件 ────────────────────────────┐
│ 空闲时间阈值：    [8] 小时             │
│ 触发延迟时间：    [立即▼] 或 [__]秒   │
│ 触发时间段：      [18:00] 至 [23:00]  │
│ 触发日期：        ☑️工作日 ☐周末       │
│ 重复提醒间隔：    [30] 分钟            │
└───────────────────────────────────────┘

┌─ 界面设置 ────────────────────────────┐
│ 激励文案库：      [编辑文案...]        │
│ 字体大小：        [中等▼]             │
│ 主题颜色：        [蓝色▼]             │
└───────────────────────────────────────┘

┌─ 集成设置 ────────────────────────────┐
│ 读取提醒事项：    ☑️启用               │
│ 读取日历：        ☑️启用               │
│ 日历筛选：        [工作, 学习]         │
└───────────────────────────────────────┘

┌─ 高级设置 ────────────────────────────┐
│ 隐藏退出快捷键：  Cmd+Opt+Ctrl+Shift+E│
│ 紧急退出限制：    最多 [3] 次/周       │
│ 开机自启动：      ☑️启用               │
└───────────────────────────────────────┘
```

---

### 2.2 未来扩展功能（非MVP）

#### 2.2.1 专注模式（后续版本）
- 选择"开始学习"后自动打开指定应用
- 屏蔽娱乐网站和应用
- 番茄钟计时器
- 白噪音播放

#### 2.2.2 时间追踪（后续版本）
- 自动检测当前使用的应用和网站
- 判断是否符合学习/工作目标
- 偏离提醒

#### 2.2.3 配置文件和菜单栏（后续版本）
- 支持导出/导入配置文件
- 菜单栏快捷操作
- 快速查看当前项目和时长

#### 2.2.4 成就徽章和激励（后续版本）
- 连续工作天数徽章
- 总时长里程碑
- 目标完成奖励动画

#### 2.2.5 智能学习（后续版本）
- AI 学习用户习惯
- 智能推荐合适的提醒时机
- 个性化激励文案

#### 2.2.6 第三方集成（后续版本）
- Notion、Todoist 等待办应用
- Google Calendar、Outlook 日历
- Toggl、RescueTime 时间追踪工具

---

## 3. 技术规格

### 3.1 技术栈

**开发语言：** Swift（SwiftUI + AppKit）

**框架与库：**
- **SwiftUI：** 主要UI框架
- **AppKit：** 全屏窗口管理、系统级交互
- **EventKit：** 日历和提醒事项集成
- **IOKit：** 系统空闲时间检测
- **UserNotifications：** 本地通知
- **Charts (Swift Charts)：** 数据可视化

**数据存储：**
- **SwiftData / Core Data：** 本地数据持久化
- **UserDefaults：** 配置项存储

**最低系统要求：** macOS 13.0 (Ventura) 及以上

### 3.2 核心技术实现

#### 3.2.1 空闲时间检测
```swift
import IOKit.pwr_mgt

func getSystemIdleTime() -> TimeInterval {
    var iterator: io_iterator_t = 0
    let result = IOServiceGetMatchingServices(
        kIOMainPortDefault,
        IOServiceMatching("IOHIDSystem"),
        &iterator
    )
    
    guard result == KERN_SUCCESS else { return 0 }
    
    let entry = IOIteratorNext(iterator)
    guard entry != 0 else { return 0 }
    
    var idleTime: CFTypeRef?
    IORegistryEntryCreateCFProperty(
        entry,
        "HIDIdleTime" as CFString,
        kCFAllocatorDefault,
        0,
        &idleTime
    )
    
    IOObjectRelease(entry)
    IOObjectRelease(iterator)
    
    if let idleTime = idleTime as? NSNumber {
        return TimeInterval(idleTime.uint64Value) / 1_000_000_000
    }
    
    return 0
}
```

#### 3.2.2 全屏窗口管理
```swift
import AppKit

class FullScreenWindow: NSWindow {
    override init(
        contentRect: NSRect,
        styleMask: NSWindow.StyleMask,
        backing: NSWindow.BackingStoreType,
        defer flag: Bool
    ) {
        super.init(
            contentRect: NSScreen.main?.frame ?? .zero,
            styleMask: [.borderless, .fullScreen],
            backing: .buffered,
            defer: false
        )
        
        self.level = .floating  // 最高层级
        self.backgroundColor = .white
        self.isOpaque = true
        self.hasShadow = false
        self.isMovable = false
        self.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]
    }
    
    // 禁用快捷键
    override func performKeyEquivalent(with event: NSEvent) -> Bool {
        // 检查隐藏退出快捷键
        if event.modifierFlags.contains([.command, .option, .control, .shift])
            && event.charactersIgnoringModifiers == "e" {
            handleEmergencyExit()
            return true
        }
        
        // 阻止其他所有快捷键
        return true
    }
}
```

#### 3.2.3 EventKit 集成
```swift
import EventKit

class CalendarManager {
    let eventStore = EKEventStore()
    
    func requestAccess() async -> Bool {
        do {
            return try await eventStore.requestAccess(to: .event)
        } catch {
            return false
        }
    }
    
    func getTodayEvents() -> [EKEvent] {
        let calendars = eventStore.calendars(for: .event)
        let startDate = Calendar.current.startOfDay(for: Date())
        let endDate = Calendar.current.date(
            byAdding: .day,
            value: 1,
            to: startDate
        )!
        
        let predicate = eventStore.predicateForEvents(
            withStart: startDate,
            end: endDate,
            calendars: calendars
        )
        
        return eventStore.events(matching: predicate)
    }
}
```

### 3.3 数据模型

#### User Session (用户会话)
```swift
@Model
class UserSession {
    var id: UUID
    var triggerTime: Date          // 触发时间
    var idleDuration: TimeInterval // 空闲时长
    var choice: SessionChoice      // 用户选择
    var project: Project?          // 关联项目
    var postponeReason: String?    // 拖延理由
    var postponeDuration: Int?     // 拖延时长(分钟)
    var actualDuration: TimeInterval? // 实际工作时长
    
    init(triggerTime: Date, idleDuration: TimeInterval) {
        self.id = UUID()
        self.triggerTime = triggerTime
        self.idleDuration = idleDuration
        self.choice = .pending
    }
}

enum SessionChoice: String, Codable {
    case pending        // 待选择
    case startWork      // 开始工作
    case postponed      // 稍后提醒
    case emergencyExit  // 紧急退出
}
```

#### Project (项目)
```swift
@Model
class Project {
    var id: UUID
    var title: String
    var type: ProjectType
    var description: String?
    var estimatedDuration: Int      // 分钟
    var createdAt: Date
    var lastWorkedAt: Date?
    var totalDuration: TimeInterval // 累计时长
    var status: ProjectStatus
    
    init(title: String, type: ProjectType, estimatedDuration: Int) {
        self.id = UUID()
        self.title = title
        self.type = type
        self.estimatedDuration = estimatedDuration
        self.createdAt = Date()
        self.totalDuration = 0
        self.status = .active
    }
}

enum ProjectType: String, Codable, CaseIterable {
    case learning   = "学习"
    case project    = "项目"
    case reading    = "阅读"
    case writing    = "写作"
    case other      = "其他"
}

enum ProjectStatus: String, Codable {
    case active     // 进行中
    case completed  // 已完成
    case abandoned  // 已放弃
}
```

#### AppSettings (应用设置)
```swift
struct AppSettings: Codable {
    var idleThreshold: TimeInterval = 8 * 3600  // 8小时
    var triggerDelay: TimeInterval = 0
    var triggerStartHour: Int = 18
    var triggerEndHour: Int = 23
    var triggerOnWeekdays: Bool = true
    var triggerOnWeekends: Bool = false
    var postponeInterval: Int = 30  // 分钟
    var motivationalQuotes: [String] = defaultQuotes
    var enableReminders: Bool = true
    var enableCalendar: Bool = true
    var calendarFilters: [String] = ["工作", "学习"]
    var emergencyExitLimit: Int = 3  // 每周最多3次
}
```

---

## 4. 用户界面设计

### 4.1 主界面（全屏引导）

**布局结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                         Header (15%)                         │
│                   欢迎标题 + 时间信息                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                       Content (60%)                          │
│                                                             │
│     激励文案 + 今日目标 + 统计信息                            │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                        Actions (25%)                         │
│                       操作按钮区域                            │
└─────────────────────────────────────────────────────────────┘
```

**颜色方案：**
- 主色调：蓝色 (#007AFF) - 专注、冷静
- 强调色：橙色 (#FF9500) - 激励、行动
- 警告色：红色 (#FF3B30) - 拖延提示
- 背景色：白色 (#FFFFFF) / 浅灰 (#F5F5F7)

**字体：**
- 标题：SF Pro Display, Bold, 36pt
- 正文：SF Pro Text, Regular, 18pt
- 按钮：SF Pro Text, Semibold, 16pt

### 4.2 设置界面

**布局：** 标准的 macOS Preferences 风格
- 左侧：分类导航
- 右侧：具体设置项

**分类：**
1. ⚙️ 通用
2. ⏰ 触发条件
3. 🎨 外观
4. 🔗 集成
5. 📊 统计
6. ℹ️ 关于

### 4.3 统计报告界面

**布局：** Dashboard 风格
```
┌──────────────────────┬──────────────────────┐
│   本周概览 (卡片)    │   项目分布 (饼图)    │
├──────────────────────┴──────────────────────┤
│            每日时长趋势 (折线图)              │
├──────────────────────┬──────────────────────┤
│  拖延分析 (列表)     │   最近项目 (列表)    │
└──────────────────────┴──────────────────────┘
```

---

## 5. 非功能性需求

### 5.1 性能要求
- **启动时间：** < 2秒
- **内存占用：** < 100MB（后台运行）
- **CPU占用：** < 5%（后台监控）
- **全屏界面响应：** < 100ms

### 5.2 可靠性
- **数据备份：** 每天自动备份到本地
- **崩溃恢复：** 程序崩溃后重启能恢复状态
- **数据完整性：** 所有操作都有事务保护

### 5.3 安全性
- **权限最小化：** 只请求必需的系统权限
- **数据本地化：** 所有数据存储在本地，不上传云端
- **紧急退出限制：** 每周最多3次，防止滥用

### 5.4 可维护性
- **代码注释率：** > 30%
- **单元测试覆盖率：** > 70%
- **模块化设计：** 功能模块独立，便于扩展

### 5.5 用户体验
- **易用性：** 首次使用有引导流程
- **可访问性：** 支持 VoiceOver
- **本地化：** 支持中文/英文

---

## 6. 开发计划

### 6.1 MVP 版本（v1.0）

**开发周期：** 4-6周

#### Week 1-2: 核心功能
- [ ] 空闲检测模块
- [ ] 全屏界面框架
- [ ] 基础数据模型
- [ ] 本地数据存储

#### Week 3-4: 功能完善
- [ ] 目标/项目管理
- [ ] "稍后提醒"阻碍机制
- [ ] 系统集成（EventKit）
- [ ] 设置面板

#### Week 5-6: 统计与优化
- [ ] 统计报告功能
- [ ] 数据可视化
- [ ] UI/UX 优化
- [ ] Bug 修复和测试

### 6.2 后续版本规划

**v1.1（+2周）**
- 配置文件导出/导入
- 菜单栏快捷操作
- 更多激励文案

**v1.2（+3周）**
- 专注模式（网站/应用屏蔽）
- 番茄钟集成
- 白噪音播放

**v2.0（+6周）**
- 时间追踪（自动检测应用使用）
- 成就徽章系统
- 第三方应用集成

---

## 7. 成功指标

### 7.1 核心指标
- **激活率：** 每周至少触发 3 次
- **开始工作率：** 选择"开始工作" ≥ 60%
- **目标完成率：** 设定的目标完成 ≥ 50%
- **持续使用：** 连续使用 4 周 ≥ 70% 用户

### 7.2 用户体验指标
- **紧急退出率：** < 10%（过高说明干扰太强）
- **设置调整频率：** 前两周 ≥ 2次（说明用户在适配）
- **统计报告查看率：** 每周至少查看 1 次 ≥ 50% 用户

---

## 8. 风险与挑战

### 8.1 技术风险
| 风险 | 影响 | 应对方案 |
|:---|:---|:---|
| macOS 系统权限限制 | 高 | 提前测试，准备降级方案 |
| 全屏窗口被系统绕过 | 中 | 多重拦截机制 |
| 性能问题（持续监控） | 中 | 优化检测频率，使用高效API |

### 8.2 用户体验风险
| 风险 | 影响 | 应对方案 |
|:---|:---|:---|
| 用户觉得太"强制"，卸载 | 高 | 提供灵活配置，降低强度 |
| 误触发导致不满 | 中 | 完善延迟触发和时间判断 |
| 统计数据不准确 | 低 | 允许手动修正数据 |

### 8.3 产品风险
| 风险 | 影响 | 应对方案 |
|:---|:---|:---|
| 用户养成"习惯性拖延" | 高 | 动态调整阻碍强度 |
| 用户找到绕过方法 | 中 | 限制紧急退出次数 |

---

## 9. 附录

### 9.1 默认激励文案库
```
1. "每一次选择都在塑造未来的你。今晚，选择成为更好的自己。"
2. "你不是没有时间，只是还没有开始。现在就是最好的时机。"
3. "成功者和普通人的区别，在于下班后的这几个小时。"
4. "今天的努力，是明天的从容。开始吧！"
5. "拖延一时爽，后悔一整年。行动起来！"
6. "你的竞争对手此刻正在学习，你呢？"
7. "专注2小时，胜过浑浑噩噩一整天。"
8. "每天进步1%，一年后你会强大37倍。"
9. "别让娱乐成为常态，让学习成为习惯。"
10. "未来的你会感谢现在努力的自己。"
```

### 9.2 拖延理由常见关键词（用于分析）
- 吃饭/晚饭
- 累/疲惫
- 消息/回复
- 休息/放松
- 临时/突然
- 家人/朋友

### 9.3 技术参考资料
- [IOKit Documentation](https://developer.apple.com/documentation/iokit)
- [EventKit Framework](https://developer.apple.com/documentation/eventkit)
- [App Sandbox](https://developer.apple.com/documentation/security/app_sandbox)
- [SwiftUI](https://developer.apple.com/xcode/swiftui/)

---

**文档版本：** v1.0  
**最后更新：** 2026-01-23  
**作者：** Focus Guardian Team  
**状态：** 待评审

---

这份PRD涵盖了你所有的需求！接下来你可以：
1. 审阅并提出修改意见
2. 确定优先级和MVP范围
3. 开始技术选型和原型开发

有什么需要调整或补充的吗？
