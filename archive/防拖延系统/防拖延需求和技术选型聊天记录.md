Wang Macro: Timing 有一个功能，就是当我离开电脑一段时间之后，再回来操作电脑，就会弹出一个框让我填写离开这段时间去干嘛了。这个功能是如何实现的？

---

Raycast AI: 

---

Tool: web_search

---

Raycast AI: Timing 的"离开电脑后填写时间"功能主要通过以下技术实现：

## 核心原理

**空闲时间检测（Idle Time Detection）** - 通过监控键盘和鼠标的活动状态来判断用户是否在使用电脑。当检测到一段时间内没有任何键盘输入或鼠标移动时，系统会将这段时间标记为"空闲时间"。[^1]

## 技术实现方式

在 macOS 系统中，可以通过系统 API 获取空闲时间。具体实现是使用 `IOHIDSystem` 来查询 `HIDIdleTime` 参数，这个值记录了自上次键盘或鼠标活动以来经过的时间：

```
ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}'
``` [^2]

## 工作流程

1. **后台监控** - Timing 在后台持续监控键盘和鼠标活动
2. **阈值触发** - 当空闲时间超过设定的阈值（默认 3 分钟，可在设置中调整），系统会记录这段时间
3. **返回提示** - 当你重新开始使用电脑时（检测到键盘或鼠标活动），Timing 会在菜单栏弹出提示框
4. **手动分配** - 你可以选择将这段离开时间分配到某个项目分类，或者在"总览"页面手动处理 [^3] [^4]

## 关键设置

在 Timing 的"Tracking"偏好设置中，可以配置空闲时间检测的行为，包括：
* 设置空闲时间阈值
* 选择检测到空闲后是否停止正在运行的计时器
* 决定是否要求用户记录离开时做了什么 [^1]

这种机制确保了即使你离开电脑去开会、打电话或做其他事情，这些时间也不会丢失，可以被准确记录和归类到相应的工作项目中。

[^1]: https://timingapp.com/help/preferences
[^2]: https://dev59.com/L3XYa4cB1Zd3GeqP2RzJ
[^3]: https://sspai.com/post/45783
[^4]: https://www.imacso.com/timing.html

---

Wang Macro: 背景：我的Mac mini 一般是 7*24 小时处于开机状态，工作日早上我去上班了，电脑也一直开着，然后下班回来之后，我一般会开始使用电脑。但是由于我是拖延症患者，我一直想要下班后回来开始学习或做其他有意义的事情，而不是沉迷于追剧或者玩游戏。
我想使用上面这个技术方案或者类似的技术方案也行，实现一个功能，就是我下班回来开始使用电脑之后，提示引导我开始学习，而不是沉迷于追剧等其他无意义的事情。

---

Raycast AI: 这是一个很有意义的需求！基于 Timing 的空闲检测原理，我可以给你几个技术实现方案：

## 方案一：AppleScript + Launchd（最简单）

创建一个 AppleScript 应用，持续监控空闲状态，在检测到"长时间空闲后重新激活"时触发提示。

**实现步骤：**

1. **创建 AppleScript**（保存为应用程序，勾选"运行处理程序后保持打开"）

```applescript
global idleThreshold, wasIdle, workHoursEnd, workHoursStart

on run
    -- 设置空闲阈值（秒），例如8小时 = 28800秒
    set idleThreshold to 28800
    set wasIdle to false
    -- 设置工作时间（24小时制）
    set workHoursEnd to 18 -- 下午6点
    set workHoursStart to 9 -- 早上9点
end run

on idle
    set currentIdleTime to (do shell script "ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}'") as number
    set currentHour to (hours of (current date))
    
    -- 如果当前空闲时间超过阈值，标记为空闲状态
    if currentIdleTime ≥ idleThreshold then
        set wasIdle to true
    end if
    
    -- 如果之前是空闲状态，现在重新激活（空闲时间小于60秒）
    if wasIdle and currentIdleTime < 60 then
        set wasIdle to false
        
        -- 只在下班时间（18:00-23:00）触发提示
        if currentHour ≥ workHoursEnd and currentHour < 23 then
            -- 显示全屏提醒对话框
            display dialog "🎯 欢迎回来！

现在是学习的好时机，你今晚想要：

✅ 开始学习新技能
✅ 完成重要项目
✅ 提升自己

而不是沉迷娱乐，浪费宝贵时间。

你准备好开始了吗？" buttons {"我需要休息", "开始学习！"} default button 2 with icon caution giving up after 30
            
            set userChoice to button returned of result
            
            if userChoice is "开始学习！" then
                -- 可以在这里打开学习相关的应用
                -- tell application "Notion" to activate
                -- 或者打开特定网站
                do shell script "open https://你的学习网站.com"
            end if
        end if
    end if
    
    -- 每30秒检查一次
    return 30
end idle
```

2. **设置为登录时自动启动**
   - 系统设置 → 通用 → 登录项 → 添加这个应用

---

## 方案二：Python 脚本（更灵活）

使用 Python 实现更强大的功能，可以添加更多智能判断。

```python
#!/usr/bin/env python3
import subprocess
import time
from datetime import datetime
import os

class FocusReminder:
    def __init__(self):
        self.idle_threshold = 8 * 60 * 60  # 8小时，单位：秒
        self.was_idle = False
        self.work_hours_end = 18  # 下午6点
        self.check_interval = 30  # 每30秒检查一次
        
    def get_idle_time(self):
        """获取系统空闲时间（秒）"""
        cmd = "ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}'"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return float(result.stdout.strip())
    
    def is_work_evening(self):
        """判断是否是工作日晚上"""
        now = datetime.now()
        # 周一到周五
        is_weekday = now.weekday() < 5
        # 18:00-23:00
        is_evening = self.work_hours_end <= now.hour < 23
        return is_weekday and is_evening
    
    def show_reminder(self):
        """显示提醒对话框"""
        script = '''
        display dialog "🎯 专注时刻到了！

你已经离开电脑很久了，现在是学习的黄金时间。

今晚的目标是什么？
• 学习新技能
• 完成重要项目  
• 阅读或写作

选择你的行动：" buttons {"稍后提醒", "查看今日目标", "立即开始！"} default button 3 with icon note
        '''
        
        result = subprocess.run(['osascript', '-e', script], 
                              capture_output=True, text=True)
        
        if "立即开始！" in result.stdout:
            self.open_focus_apps()
        elif "查看今日目标" in result.stdout:
            self.open_todo_list()
    
    def open_focus_apps(self):
        """打开学习相关的应用"""
        # 根据你的需求修改
        apps_to_open = [
            # "Notion",
            # "VS Code",
            # "Obsidian",
        ]
        for app in apps_to_open:
            os.system(f'open -a "{app}"')
    
    def open_todo_list(self):
        """打开待办事项"""
        # 可以打开你的任务管理工具
        os.system('open -a "Reminders"')
    
    def block_distractions(self):
        """可选：屏蔽干扰网站"""
        # 可以集成 Focus、Cold Turkey 等应用的 CLI
        pass
    
    def run(self):
        """主循环"""
        print("Focus Reminder 已启动...")
        print(f"空闲阈值: {self.idle_threshold/3600}小时")
        
        while True:
            try:
                idle_time = self.get_idle_time()
                
                # 标记空闲状态
                if idle_time >= self.idle_threshold:
                    self.was_idle = True
                    print(f"检测到长时间空闲: {idle_time/3600:.2f}小时")
                
                # 检测重新激活
                if self.was_idle and idle_time < 60:
                    print("检测到重新激活电脑")
                    self.was_idle = False
                    
                    # 只在工作日晚上触发
                    if self.is_work_evening():
                        print("触发学习提醒...")
                        self.show_reminder()
                    else:
                        print("非工作日晚上，跳过提醒")
                
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                print("\n程序已停止")
                break
            except Exception as e:
                print(f"错误: {e}")
                time.sleep(self.check_interval)

if __name__ == "__main__":
    reminder = FocusReminder()
    reminder.run()
```

**使用方法：**

1. 保存为 `focus_reminder.py`
2. 添加执行权限：`chmod +x focus_reminder.py`
3. 创建 launchd 配置让它开机自启

创建 `~/Library/LaunchAgents/com.focusreminder.plist`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.focusreminder</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/python3</string>
        <string>/Users/你的用户名/focus_reminder.py</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
```

加载服务：
```bash
launchctl load ~/Library/LaunchAgents/com.focusreminder.plist
```

---

## 方案三：使用现成工具组合

如果不想写代码，可以组合使用现有工具：

1. **Hammerspoon**（Lua 脚本自动化工具）
   - 免费且强大的 macOS 自动化工具
   - 可以监控空闲时间并触发动作

2. **Keyboard Maestro** + **Focus/Cold Turkey**
   - Keyboard Maestro 检测空闲恢复
   - 自动启动专注模式，屏蔽干扰网站

3. **Shortcuts（快捷指令）** + **个人自动化**
   - 结合系统的屏幕时间功能
   - 创建自动化流程

---

## 推荐的增强功能

1. **智能判断**：
   - 识别工作日 vs 周末
   - 区分不同时间段（早晨、下午、晚上）
   - 记录你的学习习惯，在最佳时间提醒

2. **渐进式提醒**：
   - 第一次温和提醒
   - 如果继续娱乐，逐渐增强提醒强度

3. **数据跟踪**：
   - 记录每次的选择
   - 生成每周学习报告
   - 可视化你的进步

4. **激励机制**：
   - 连续学习天数打卡
   - 设置学习目标和奖励

你觉得哪个方案更适合你？我可以帮你进一步完善具体的实现细节。

---

Wang Macro: 我们先来讨论需求吧。你来问我问题，我来回答，形成一份用户旅程，然后再根据用户流程形成一份 PRD。我现在想到的就是，要有一个可视化的界面，然后激活以后要弹出一个全屏的界面且不能关闭。

---

Raycast AI: 好的！我来通过提问帮你梳理清楚整个需求。让我们一步步来：

## 第一部分：触发条件

**Q1: 空闲时间阈值**
- 你希望电脑空闲多久后，才算是"你离开了电脑"？
  - 比如：6小时？8小时？还是可以自定义？

**Q2: 激活检测时间**
- 当你重新使用电脑后，多快触发提醒？
  - 立即触发？还是等待一段时间（比如活动超过30秒后）？

**Q3: 触发时间段限制**
- 你只想在特定时间段触发吗？
  - 工作日晚上（比如18:00-23:00）？
  - 还是包括周末？
  - 早上需要触发吗？

**Q4: 重复触发**
- 如果你选择了"稍后"或关闭提醒后，继续娱乐了一段时间，需要再次提醒吗？
  - 如果需要，间隔多久？（比如30分钟后再提醒）

---

## 第二部分：全屏界面内容

**Q5: 界面要展示什么信息？**
你提到要全屏且不能关闭，那么界面上应该显示：
- 一段激励文字/问候语？
- 今天的日期和时间？
- 你离开电脑的时长统计？
- 今日学习目标/待办事项？
- 其他什么？

**Q6: 用户必须做出选择吗？**
既然不能关闭，用户需要通过什么方式才能继续使用电脑？
- 必须选择一个"今晚要做的事情"？
- 必须输入今晚的学习目标？
- 还是其他形式的"承诺"？

**Q7: 具体有哪些选项？**
你希望给自己提供哪些选择？比如：
- ✅ 开始学习（然后进入专注模式）
- 📝 查看/设置今日目标
- 🎯 快速开始某个具体项目
- ⏰ 我需要休息15分钟
- 🎮 我就是要娱乐（需要额外确认？）

---

## 第三部分：选择后的行为

**Q8: 选择"开始学习"后要做什么？**
- 自动打开特定应用（比如VS Code、Notion、Obsidian）？
- 启动专注模式（屏蔽娱乐网站/应用）？
- 启动计时器追踪学习时间？
- 播放专注音乐？

**Q9: 专注模式的具体内容**
如果选择学习，是否要：
- 屏蔽特定网站（YouTube、Netflix、B站等）？
- 禁用特定应用（游戏、视频播放器）？
- 持续时间多久？（比如默认25分钟一个番茄钟）
- 能否中途退出？需要什么条件？

**Q10: 选择"休息/娱乐"后**
- 需要设置一个休息时长吗？（比如15/30/60分钟）
- 时间到了后再次提醒？
- 还是完全放开，不再管控？

---

## 第四部分：数据记录与反馈

**Q11: 需要记录什么数据？**
- 每次的选择（学习/休息/娱乐）？
- 实际学习时长？
- 连续学习天数？
- 每周学习总时长？

**Q12: 数据展示方式**
- 需要一个统计面板吗？
- 每天/每周生成报告？
- 显示进度条、成就徽章等激励元素？

**Q13: 目标设置**
- 需要设定学习目标吗？（比如每天学习2小时）
- 未完成目标时有提醒吗？
- 完成目标有庆祝动画或提示吗？

---

## 第五部分：配置与设置

**Q14: 可配置项**
你希望能自定义哪些内容？
- 空闲时间阈值
- 触发时间段
- 屏蔽的网站/应用列表
- 激励语/提醒文案
- 专注时长
- 提醒频率

**Q15: 配置界面**
- 需要一个独立的设置面板吗？
- 还是通过配置文件修改？
- 是否需要菜单栏图标方便快速访问？

---

## 第六部分：特殊场景

**Q16: 紧急退出**
虽然全屏不可关闭，但遇到紧急情况怎么办？
- 是否需要一个"隐藏的退出方式"？（比如特定快捷键组合）
- 还是完全不允许关闭？

**Q17: 系统重启**
如果你重启电脑，程序如何处理？
- 记住之前的状态？
- 重新开始判断？

**Q18: 误触发处理**
如果你只是短暂使用电脑（比如查看一条消息），不想被打断怎么办？
- 需要延迟触发机制吗？
- 还是每次都弹出？

---

请你先回答这些问题，我会根据你的回答整理出完整的用户旅程和PRD文档！你可以分几次回答，不用一次全部答完。

---

Wang Macro: Q1：可以自定义
Q2：也是自定义，默认是立即触发
Q3：我现阶段的需求是工作日晚上
Q4：需要再次提醒，间隔多久：自定义
Q5：一段激励文字/问候语，今天的日期和时间，今日学习目标/待办事项，可以集成 Mac 系统的提醒事项和日历，后续考虑集成其他的待办应用和日历应用
Q6：必须选择或者输入“今晚要做的事情”，当然也可以选择稍后提醒，但是必须要有一个限制时间，限制时间到了之后再次提醒。并且选择稍后提醒的话，必须要有理由，为什么要稍后提醒，选择稍后提醒这段时间你要做什么事情？为什么要做这件事情？反正就是要设置重重阻碍
Q7：查看/设置今日目标、快速开始某个具体项目。我需要休息 15 分钟或者我就是要娱乐可以提供选择，但是就像 Q6 我说的，要设置重重阻碍。
Q8：暂时不做什么，作为后续扩展
Q9：暂时不做什么，作为后续扩展
Q10：需要设置一个休息时长、时间到了后再次提醒
Q11：每次的选择，其他的还没想好，也不是都是要学习，也可以是做什么具体的项目
Q12：需要统计面板、每天/每周生成报告，但是报告的内容还没想好。显示进度条、成就徽章等激励元素可以作为后续扩展
Q13：感觉需要有目标设置，但是时长要如何检测呢？比如说选择了要学习（假设有学习），但实际却是去干别的了，这怎么办？
Q14：空闲时间阈值、触发时间段、屏蔽的网站/应用列表、激励语/提醒文案、专注时长、提醒频率
Q15：需要有独立的设置面板，配置文件修改和菜单栏快速方案作为后续扩展
Q16：需要一个“隐藏的退出方式”
Q17：重新开始判断
Q18：需要延迟触发机制

---

Raycast AI: 非常好！你的回答很详细。现在让我基于你的回答整理出完整的用户旅程和PRD文档。

---

# 用户旅程地图 (User Journey Map)

## 场景：工作日晚上回家后激活电脑

### 阶段 1：离开电脑（上班时段）
**用户行为：**
- 早上去上班，Mac mini 保持开机状态
- 电脑空闲时长开始累积

**系统行为：**
- 后台监控键盘/鼠标活动
- 记录空闲时长
- 当空闲时长 > 自定义阈值（默认8小时），标记为"长时间离开"状态

**用户情绪：** 😐 中性

---

### 阶段 2：下班回家，接近电脑
**用户行为：**
- 下班回到家（18:00-23:00 工作日晚上时段）
- 准备使用电脑

**系统行为：**
- 等待用户交互

**用户情绪：** 😊 期待使用电脑

---

### 阶段 3：初次接触电脑（延迟触发检测）
**用户行为：**
- 移动鼠标或按下键盘

**系统行为：**
- 检测到用户活动
- **启动延迟触发计时器**（默认立即触发，可自定义如30秒）
- 判断：
  - ✅ 当前时间在工作日晚上（18:00-23:00）
  - ✅ 之前空闲时长 > 阈值
  - ✅ 用户持续活动 > 延迟触发时长
  - → **触发全屏界面**

**用户情绪：** 😯 被打断但预期之中

---

### 阶段 4：全屏界面出现 🎯

**界面布局：**
```
┌─────────────────────────────────────────────────────────────┐
│                     🌟 欢迎回来！现在是专注时刻 🌟                    │
│                                                             │
│                  📅 2026年1月23日 星期四 19:30               │
│                  ⏰ 你已经离开电脑 9小时32分钟                  │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  💡 今日激励：                                               │
│  "每一次选择都在塑造未来的你。今晚，选择成为更好的自己。"          │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  📝 今日目标与待办：                                          │
│  □ 完成 Python 项目第三章（来自提醒事项）                       │
│  □ 21:00 线上读书会（来自日历）                               │
│  □ 学习 SwiftUI 1小时                                        │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│           今晚你打算做什么？（必选）                            │
│                                                             │
│  [📋 查看/设置今日目标]  [🚀 快速开始具体项目]                   │
│                                                             │
│            还没准备好？                                        │
│  [⏰ 稍后提醒（需说明理由）]                                    │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**系统行为：**
- 全屏覆盖，无法点击其他区域
- 禁用 Cmd+Q、Cmd+W 等常规退出快捷键
- 隐藏退出方式：Cmd+Option+Control+Shift+E（应急使用）

**用户情绪：** 🤔 需要思考和决策

---

### 阶段 5A：用户选择"📋 查看/设置今日目标"

**用户行为：**
- 点击"查看/设置今日目标"

**系统行为：**
- 在当前全屏界面展开目标设置表单

**界面变化：**
```
┌─────────────────────────────────────────────────────────────┐
│                     设置今晚目标                              │
│                                                             │
│  目标标题：                                                   │
│  [_________________________________________________]        │
│                                                             │
│  预计时长：                                                   │
│  [ 30分钟 ▼ ]  [ 1小时 ▼ ]  [ 2小时 ▼ ]  [自定义___分钟]     │
│                                                             │
│  目标类型：                                                   │
│  ( ) 学习  ( ) 项目  ( ) 阅读  ( ) 写作  ( ) 其他            │
│                                                             │
│  具体描述（可选）：                                            │
│  [_________________________________________________]        │
│  [_________________________________________________]        │
│                                                             │
│              [取消]        [保存并开始]                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**后续流程：**
- 用户填写完成 → 点击"保存并开始" → **关闭全屏界面，进入正常使用**
- 系统开始追踪这个目标的时间（可选功能，后续扩展）

**用户情绪：** 💪 明确目标，有动力

---

### 阶段 5B：用户选择"🚀 快速开始具体项目"

**用户行为：**
- 点击"快速开始具体项目"

**系统行为：**
- 显示最近的项目列表（从历史记录中读取）

**界面变化：**
```
┌─────────────────────────────────────────────────────────────┐
│                   选择要继续的项目                             │
│                                                             │
│  最近项目：                                                   │
│  ┌─────────────────────────────────────────────┐            │
│  │ 🐍 Python 自动化脚本开发  [继续]              │            │
│  │    上次工作：昨天 21:30  累计：5小时30分       │            │
│  └─────────────────────────────────────────────┘            │
│                                                             │
│  ┌─────────────────────────────────────────────┐            │
│  │ 📱 SwiftUI 学习  [继续]                      │            │
│  │    上次工作：3天前  累计：2小时15分            │            │
│  └─────────────────────────────────────────────┘            │
│                                                             │
│  ┌─────────────────────────────────────────────┐            │
│  │ ✏️ 博客文章写作  [继续]                       │            │
│  │    上次工作：1周前  累计：3小时45分            │            │
│  └─────────────────────────────────────────────┘            │
│                                                             │
│              [返回]        [+ 新建项目]                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**后续流程：**
- 点击某个项目 → **关闭全屏界面，开始追踪该项目时间**
- 点击"新建项目" → 跳转到类似 5A 的创建界面

**用户情绪：** 🎯 清晰，快速进入状态

---

### 阶段 5C：用户选择"⏰ 稍后提醒"（重重阻碍）

**用户行为：**
- 点击"稍后提醒"

**系统行为：**
- 弹出"阻碍层级1"

**界面变化：**
```
┌─────────────────────────────────────────────────────────────┐
│                   ⚠️ 真的要稍后吗？                            │
│                                                             │
│  选择稍后意味着推迟你的成长和进步。                             │
│                                                             │
│  请告诉我你的理由：                                            │
│                                                             │
│  稍后这段时间我需要：                                          │
│  [_________________________________________________]        │
│                                                             │
│  这件事为什么必须现在做？                                      │
│  [_________________________________________________]        │
│  [_________________________________________________]        │
│                                                             │
│  推迟多久？                                                   │
│  ( ) 15分钟  ( ) 30分钟  ( ) 1小时  ( ) 自定义___分钟         │
│                                                             │
│  ⚠️ 注意：选择稍后后，这段时间将被记录为"拖延时间"                │
│                                                             │
│              [我想清楚了，开始工作]   [确认稍后]               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**条件判断：**
- 如果用户点击"我想清楚了，开始工作" → 返回主界面（阶段4）
- 如果用户填写理由 < 10个字 → 提示"请认真思考并详细说明理由"
- 如果理由合理且时长已选 → 点击"确认稍后" → **进入阻碍层级2**

**界面变化（阻碍层级2）：**
```
┌─────────────────────────────────────────────────────────────┐
│                   🤔 最后确认                                 │
│                                                             │
│  你即将推迟 30分钟，理由是：                                   │
│  "需要吃晚饭，还没来得及吃"                                    │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  💭 反思一下：                                                │
│                                                             │
│  • 这件事真的不能在工作后做吗？                                │
│  • 30分钟后你真的会开始工作，还是会继续拖延？                   │
│  • 今天已经是本周第 X 次选择"稍后提醒"了                       │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  请在下方输入"我确认稍后提醒"来继续：                           │
│  [_________________________________________________]        │
│                                                             │
│              [重新考虑]        [确认（输入后激活）]             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**后续流程：**
- 用户必须完整输入"我确认稍后提醒" → 按钮才激活
- 点击确认 → **关闭全屏界面**
- **系统记录：**
  - 拖延时间：30分钟
  - 拖延理由："需要吃晚饭"
  - 拖延次数 +1
- **30分钟后 → 再次弹出全屏界面（回到阶段4）**

**用户情绪：** 😰 感到压力，但可能仍然选择拖延 / 😤 被激励，改变主意

---

### 阶段 6：开始工作/学习

**用户行为：**
- 完成选择后，开始使用电脑进行学习/工作

**系统行为：**
- 全屏界面关闭
- 系统静默运行，追踪时间（如果用户选择了具体项目）
- 菜单栏显示图标，显示当前项目和已工作时长（可选）

**用户情绪：** 💪 专注，有目标感

---

### 阶段 7：中途检查（可选扩展功能）

**时间节点：**
- 用户工作一段时间后（如1小时）

**系统行为：**
- 发送轻量通知："已专注1小时，干得漂亮！💪"
- 不打断用户，仅作鼓励

---

### 阶段 8：完成或中断

**场景A：用户完成目标**
- 系统检测到目标时长已达到
- 发送祝贺通知："🎉 目标达成！今晚学习2小时完成！"
- 记录到统计数据

**场景B：用户中途离开**
- 检测到再次空闲 > X 分钟（可自定义）
- 记录实际工作时长
- 下次激活时询问："上次的任务完成了吗？"

**用户情绪：** 😊 成就感 / 😐 部分完成

---

### 阶段 9：查看统计报告

**用户行为：**
- 点击菜单栏图标 → "查看统计"
- 或在设置面板中查看

**界面展示：**
```
┌─────────────────────────────────────────────────────────────┐
│                   📊 本周统计报告                             │
│                                                             │
│  本周工作日晚上（共5天）：                                     │
│  ✅ 开始工作/学习：4次                                        │
│  ⏰ 选择稍后提醒：3次                                         │
│  📝 总工作时长：12小时30分钟                                  

---

Wang Macro: 继续

---

Raycast AI: ```
│  📈 平均每天：2.5小时                                         │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  项目时间分布：                                               │
│  🐍 Python 开发      ████████░░  6小时15分  (50%)          │
│  📱 SwiftUI 学习     ████░░░░░░  3小时30分  (28%)          │
│  ✏️ 博客写作         ███░░░░░░░  2小时45分  (22%)          │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  拖延分析：                                                   │
│  • 本周选择"稍后提醒" 3次，累计拖延时长 1小时30分             │
│  • 最常见理由：吃饭(2次)、临时消息(1次)                        │
│                                                             │
│  ──────────────────────────────────────────────────────     │
│                                                             │
│  🏆 成就：                                                   │
│  ✨ 连续工作 4 天                                            │
│  🔥 本周目标完成率：80%                                       │
│                                                             │
│            [导出报告]    [查看详细数据]    [关闭]             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**用户情绪：** 📊 清晰了解自己的进展，有数据支撑的成就感或反思

---

### 阶段 10：持续优化

**用户行为：**
- 根据统计数据调整行为
- 在设置中优化参数

**系统行为：**
- 学习用户习惯（后续扩展）
- 在合适时机发送激励

**用户情绪：** 🎯 持续改进

---

## 异常场景处理

### 异常 1：误触发（短暂使用）
**场景：** 用户只是查看一条消息就离开

**解决方案：** 延迟触发机制
- 用户活动 < 延迟时间（如30秒）→ 不触发
- 活动 > 延迟时间 → 才弹出全屏界面

### 异常 2：紧急情况需要立即使用电脑
**场景：** 接到紧急工作电话，需要立即操作电脑

**解决方案：** 隐藏退出方式
- 按 `Cmd+Option+Control+Shift+E` → 弹出确认对话框
- 输入"紧急情况"文本 → 才能关闭全屏界面
- 系统记录紧急退出次数（防止滥用）

### 异常 3：系统重启后
**场景：** 电脑重启或程序崩溃

**解决方案：**
- 程序启动时重新开始监控
- 不恢复之前的状态
- 清空"长时间离开"标记

### 异常 4：周末意外触发
**场景：** 虽然设置了只在工作日触发，但周末也可能长时间离开后返回

**解决方案：**
- 严格检查时间条件
- 周末不触发（按照用户设置）

---

---

# PRD 文档 (Product Requirements Document)

## 1. 产品概述

### 1.1 产品名称
**Focus Guardian**（专注守护者）

### 1.2 产品定位
一款帮助拖延症患者在下班后保持专注、养成良好学习习惯的 macOS 应用程序。通过智能检测用户空闲状态，在重新使用电脑时强制引导用户做出有意义的选择，减少娱乐拖延，提升个人成长效率。

### 1.3 目标用户
- **主要用户：** 有拖延症的职场人士，下班后想要学习提升但容易沉迷娱乐
- **使用场景：** 工作日晚上（18:00-23:00），长时间离开电脑后重新使用
- **痛点：** 
  - 容易忘记学习目标，习惯性打开娱乐应用
  - 缺乏自律，需要外部提醒和"强制"引导
  - 不知道自己的时间都花在哪里，缺少数据支持

### 1.4 核心价值
- **强制决策：** 全屏界面，必须做出选择才能继续使用电脑
- **重重阻碍：** 通过多层确认和理由填写，增加选择娱乐/拖延的心理成本
- **数据可视：** 清晰的统计报告，让用户看到自己的进步和拖延模式
- **灵活配置：** 多项参数可自定义，适应不同用户需求

---

## 2. 功能需求

### 2.1 核心功能（MVP 必需）

#### 2.1.1 空闲检测与触发
**功能描述：**
- 后台持续监控键盘和鼠标活动
- 当空闲时长超过阈值时，标记为"长时间离开"
- 用户重新激活电脑时，触发全屏提醒界面

**详细规格：**

| 参数 | 默认值 | 可配置范围 | 说明 |
|:---|:---|:---|:---|
| 空闲时间阈值 | 8小时 | 1-24小时 | 多久算"长时间离开" |
| 触发延迟时间 | 立即（0秒） | 0-300秒 | 用户活动多久后才触发界面 |
| 触发时间段 | 18:00-23:00 工作日 | 自定义时间段+星期 | 只在特定时间触发 |
| 重复提醒间隔 | 30分钟 | 5-120分钟 | 选择"稍后"后多久再次提醒 |

**技术实现：**
- 使用 `IOHIDSystem` 获取系统空闲时间
- 每30秒检查一次状态
- 使用 NSDate 判断当前时间和星期

#### 2.1.2 全屏引导界面
**功能描述：**
- 全屏覆盖，无法点击其他区域
- 展示激励文案、时间信息、今日目标
- 提供多个选择按钮

**界面元素：**

| 元素 | 必需/可选 | 说明 |
|:---|:---|:---|
| 欢迎标题 | 必需 | 如"欢迎回来！现在是专注时刻" |
| 日期时间 | 必需 | 当前日期和时间 |
| 离开时长 | 必需 | 显示空闲了多久 |
| 激励文案 | 必需 | 随机或按日期显示 |
| 今日目标列表 | 可选 | 从系统提醒事项和日历读取 |
| 操作按钮 | 必需 | 至少2个主要操作 |

**交互规则：**
- 禁用 Cmd+Q, Cmd+W, Cmd+H 等快捷键
- 禁用鼠标右键
- 禁用触控板手势（三指滑动、四指缩放）
- ESC 键无效
- 隐藏退出：`Cmd+Option+Control+Shift+E`

#### 2.1.3 目标设置与项目管理
**功能描述：**
用户可以创建、查看、选择今晚要完成的目标或项目

**目标属性：**

| 字段 | 类型 | 必需 | 说明 |
|:---|:---|:---|:---|
| 标题 | 文本 | ✅ | 目标名称 |
| 预计时长 | 数字 | ✅ | 30分钟/1小时/2小时/自定义 |
| 类型 | 枚举 | ✅ | 学习/项目/阅读/写作/其他 |
| 描述 | 文本 | ❌ | 可选的详细描述 |
| 创建时间 | 时间戳 | 自动 | 系统自动记录 |
| 状态 | 枚举 | 自动 | 进行中/已完成/已放弃 |

**项目列表：**
- 显示最近使用的3-5个项目
- 每个项目显示：名称、上次工作时间、累计时长
- 支持快速继续或新建项目

#### 2.1.4 "稍后提醒"阻碍机制
**功能描述：**
通过多层确认和理由填写，增加选择拖延的心理成本

**阻碍层级 1 - 理由说明：**

| 字段 | 验证规则 | 说明 |
|:---|:---|:---|
| 需要做什么 | 最少10个字 | 必须详细说明 |
| 为什么必须现在做 | 最少10个字 | 必须说明紧迫性 |
| 推迟时长 | 选择或输入 | 15/30/60分钟或自定义 |

**阻碍层级 2 - 最终确认：**
- 回显用户填写的理由
- 显示反思问题（3个引导性问题）
- 显示本周"稍后"次数统计
- 必须输入"我确认稍后提醒"才能激活确认按钮

**记录数据：**
- 拖延时间
- 拖延理由
- 拖延次数（每周/每月）

#### 2.1.5 系统集成（提醒事项和日历）
**功能描述：**
读取 macOS 系统的提醒事项和日历事件，展示在全屏界面

**提醒事项集成：**
- 使用 EventKit 框架读取
- 筛选条件：今天到期且未完成
- 显示格式：`□ 任务标题`
- 支持点击后打开系统提醒事项应用

**日历集成：**
- 读取今天和明天的事件
- 筛选：工作/学习相关日历（可配置）
- 显示格式：`□ HH:mm 事件标题`
- 支持点击后打开系统日历应用

**权限处理：**
- 首次运行时请求日历和提醒事项权限
- 如果用户拒绝，显示手动输入选项

#### 2.1.6 统计与报告
**功能描述：**
记录用户的选择和时间使用情况，生成可视化报告

**记录数据：**

| 数据项 | 记录时机 | 用途 |
|:---|:---|:---|
| 每次选择（开始工作/稍后提醒） | 用户做出选择时 | 统计工作vs拖延比例 |
| 选择理由（如果稍后） | 选择稍后时 | 分析拖延模式 |
| 项目/目标信息 | 开始工作时 | 时间分布分析 |
| 预计时长 vs 实际时长 | 结束时 | 目标完成率 |
| 触发时间 | 每次弹窗时 | 使用模式分析 |

**统计报告内容：**

**每日统计：**
- 今日是否触发
- 选择了什么
- 工作时长
- 目标完成情况

**每周报告：**
```
• 本周工作日晚上触发次数：X/5
• 开始工作次数：X
• 选择稍后次数：X
• 总工作时长：XX小时XX分钟
• 项目时间分布（饼图/柱状图）
• 拖延分析（次数、时长、常见理由）
• 连续工作天数
• 目标完成率
```

**可视化元素：**
- 进度条（时间分布）
- 柱状图（每日工作时长）
- 饼图（项目占比）
- 日历热力图（工作天数可视化）

#### 2.1.7 设置面板
**功能描述：**
独立的设置界面，允许用户自定义各项参数

**设置分类：**

**基础设置：**
```
┌─ 触发条件 ────────────────────────────┐
│ 空闲时间阈值：    [8] 小时             │
│ 触发延迟时间：    [立即▼] 或 [__]秒   │
│ 触发时间段：      [18:00] 至 [23:00]  │
│ 触发日期：        ☑️工作日 ☐周末       │
│ 重复提醒间隔：    [30] 分钟            │
└───────────────────────────────────────┘

┌─ 界面设置 ────────────────────────────┐
│ 激励文案库：      [编辑文案...]        │
│ 字体大小：        [中等▼]             │
│ 主题颜色：        [蓝色▼]             │
└───────────────────────────────────────┘

┌─ 集成设置 ────────────────────────────┐
│ 读取提醒事项：    ☑️启用               │
│ 读取日历：        ☑️启用               │
│ 日历筛选：        [工作, 学习]         │
└───────────────────────────────────────┘

┌─ 高级设置 ────────────────────────────┐
│ 隐藏退出快捷键：  Cmd+Opt+Ctrl+Shift+E│
│ 紧急退出限制：    最多 [3] 次/周       │
│ 开机自启动：      ☑️启用               │
└───────────────────────────────────────┘
```

---

### 2.2 未来扩展功能（非MVP）

#### 2.2.1 专注模式（后续版本）
- 选择"开始学习"后自动打开指定应用
- 屏蔽娱乐网站和应用
- 番茄钟计时器
- 白噪音播放

#### 2.2.2 时间追踪（后续版本）
- 自动检测当前使用的应用和网站
- 判断是否符合学习/工作目标
- 偏离提醒

#### 2.2.3 配置文件和菜单栏（后续版本）
- 支持导出/导入配置文件
- 菜单栏快捷操作
- 快速查看当前项目和时长

#### 2.2.4 成就徽章和激励（后续版本）
- 连续工作天数徽章
- 总时长里程碑
- 目标完成奖励动画

#### 2.2.5 智能学习（后续版本）
- AI 学习用户习惯
- 智能推荐合适的提醒时机
- 个性化激励文案

#### 2.2.6 第三方集成（后续版本）
- Notion、Todoist 等待办应用
- Google Calendar、Outlook 日历
- Toggl、RescueTime 时间追踪工具

---

## 3. 技术规格

### 3.1 技术栈

**开发语言：** Swift（SwiftUI + AppKit）

**框架与库：**
- **SwiftUI：** 主要UI框架
- **AppKit：** 全屏窗口管理、系统级交互
- **EventKit：** 日历和提醒事项集成
- **IOKit：** 系统空闲时间检测
- **UserNotifications：** 本地通知
- **Charts (Swift Charts)：** 数据可视化

**数据存储：**
- **SwiftData / Core Data：** 本地数据持久化
- **UserDefaults：** 配置项存储

**最低系统要求：** macOS 13.0 (Ventura) 及以上

### 3.2 核心技术实现

#### 3.2.1 空闲时间检测
```swift
import IOKit.pwr_mgt

func getSystemIdleTime() -> TimeInterval {
    var iterator: io_iterator_t = 0
    let result = IOServiceGetMatchingServices(
        kIOMainPortDefault,
        IOServiceMatching("IOHIDSystem"),
        &iterator
    )
    
    guard result == KERN_SUCCESS else { return 0 }
    
    let entry = IOIteratorNext(iterator)
    guard entry != 0 else { return 0 }
    
    var idleTime: CFTypeRef?
    IORegistryEntryCreateCFProperty(
        entry,
        "HIDIdleTime" as CFString,
        kCFAllocatorDefault,
        0,
        &idleTime
    )
    
    IOObjectRelease(entry)
    IOObjectRelease(iterator)
    
    if let idleTime = idleTime as? NSNumber {
        return TimeInterval(idleTime.uint64Value) / 1_000_000_000
    }
    
    return 0
}
```

#### 3.2.2 全屏窗口管理
```swift
import AppKit

class FullScreenWindow: NSWindow {
    override init(
        contentRect: NSRect,
        styleMask: NSWindow.StyleMask,
        backing: NSWindow.BackingStoreType,
        defer flag: Bool
    ) {
        super.init(
            contentRect: NSScreen.main?.frame ?? .zero,
            styleMask: [.borderless, .fullScreen],
            backing: .buffered,
            defer: false
        )
        
        self.level = .floating  // 最高层级
        self.backgroundColor = .white
        self.isOpaque = true
        self.hasShadow = false
        self.isMovable = false
        self.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]
    }
    
    // 禁用快捷键
    override func performKeyEquivalent(with event: NSEvent) -> Bool {
        // 检查隐藏退出快捷键
        if event.modifierFlags.contains([.command, .option, .control, .shift])
            && event.charactersIgnoringModifiers == "e" {
            handleEmergencyExit()
            return true
        }
        
        // 阻止其他所有快捷键
        return true
    }
}
```

#### 3.2.3 EventKit 集成
```swift
import EventKit

class CalendarManager {
    let eventStore = EKEventStore()
    
    func requestAccess() async -> Bool {
        do {
            return try await eventStore.requestAccess(to: .event)
        } catch {
            return false
        }
    }
    
    func getTodayEvents() -> [EKEvent] {
        let calendars = eventStore.calendars(for: .event)
        let startDate = Calendar.current.startOfDay(for: Date())
        let endDate = Calendar.current.date(
            byAdding: .day,
            value: 1,
            to: startDate
        )!
        
        let predicate = eventStore.predicateForEvents(
            withStart: startDate,
            end: endDate,
            calendars: calendars
        )
        
        return eventStore.events(matching: predicate)
    }
}
```

### 3.3 数据模型

#### User Session (用户会话)
```swift
@Model
class UserSession {
    var id: UUID
    var triggerTime: Date          // 触发时间
    var idleDuration: TimeInterval // 空闲时长
    var choice: SessionChoice      // 用户选择
    var project: Project?          // 关联项目
    var postponeReason: String?    // 拖延理由
    var postponeDuration: Int?     // 拖延时长(分钟)
    var actualDuration: TimeInterval? // 实际工作时长
    
    init(triggerTime: Date, idleDuration: TimeInterval) {
        self.id = UUID()
        self.triggerTime = triggerTime
        self.idleDuration = idleDuration
        self.choice = .pending
    }
}

enum SessionChoice: String, Codable {
    case pending        // 待选择
    case startWork      // 开始工作
    case postponed      // 稍后提醒
    case emergencyExit  // 紧急退出
}
```

#### Project (项目)
```swift
@Model
class Project {
    var id: UUID
    var title: String
    var type: ProjectType
    var description: String?
    var estimatedDuration: Int      // 分钟
    var createdAt: Date
    var lastWorkedAt: Date?
    var totalDuration: TimeInterval // 累计时长
    var status: ProjectStatus
    
    init(title: String, type: ProjectType, estimatedDuration: Int) {
        self.id = UUID()
        self.title = title
        self.type = type
        self.estimatedDuration = estimatedDuration
        self.createdAt = Date()
        self.totalDuration = 0
        self.status = .active
    }
}

enum ProjectType: String, Codable, CaseIterable {
    case learning   = "学习"
    case project    = "项目"
    case reading    = "阅读"
    case writing    = "写作"
    case other      = "其他"
}

enum ProjectStatus: String, Codable {
    case active     // 进行中
    case completed  // 已完成
    case abandoned  // 已放弃
}
```

#### AppSettings (应用设置)
```swift
struct AppSettings: Codable {
    var idleThreshold: TimeInterval = 8 * 3600  // 8小时
    var triggerDelay: TimeInterval = 0
    var triggerStartHour: Int = 18
    var triggerEndHour: Int = 23
    var triggerOnWeekdays: Bool = true
    var triggerOnWeekends: Bool = false
    var postponeInterval: Int = 30  // 分钟
    var motivationalQuotes: [String] = defaultQuotes
    var enableReminders: Bool = true
    var enableCalendar: Bool = true
    var calendarFilters: [String] = ["工作", "学习"]
    var emergencyExitLimit: Int = 3  // 每周最多3次
}
```

---

## 4. 用户界面设计

### 4.1 主界面（全屏引导）

**布局结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                         Header (15%)                         │
│                   欢迎标题 + 时间信息                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                       Content (60%)                          │
│                                                             │
│     激励文案 + 今日目标 + 统计信息                            │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                        Actions (25%)                         │
│                       操作按钮区域                            │
└─────────────────────────────────────────────────────────────┘
```

**颜色方案：**
- 主色调：蓝色 (#007AFF) - 专注、冷静
- 强调色：橙色 (#FF9500) - 激励、行动
- 警告色：红色 (#FF3B30) - 拖延提示
- 背景色：白色 (#FFFFFF) / 浅灰 (#F5F5F7)

**字体：**
- 标题：SF Pro Display, Bold, 36pt
- 正文：SF Pro Text, Regular, 18pt
- 按钮：SF Pro Text, Semibold, 16pt

### 4.2 设置界面

**布局：** 标准的 macOS Preferences 风格
- 左侧：分类导航
- 右侧：具体设置项

**分类：**
1. ⚙️ 通用
2. ⏰ 触发条件
3. 🎨 外观
4. 🔗 集成
5. 📊 统计
6. ℹ️ 关于

### 4.3 统计报告界面

**布局：** Dashboard 风格
```
┌──────────────────────┬──────────────────────┐
│   本周概览 (卡片)    │   项目分布 (饼图)    │
├──────────────────────┴──────────────────────┤
│            每日时长趋势 (折线图)              │
├──────────────────────┬──────────────────────┤
│  拖延分析 (列表)     │   最近项目 (列表)    │
└──────────────────────┴──────────────────────┘
```

---

## 5. 非功能性需求

### 5.1 性能要求
- **启动时间：** < 2秒
- **内存占用：** < 100MB（后台运行）
- **CPU占用：** < 5%（后台监控）
- **全屏界面响应：** < 100ms

### 5.2 可靠性
- **数据备份：** 每天自动备份到本地
- **崩溃恢复：** 程序崩溃后重启能恢复状态
- **数据完整性：** 所有操作都有事务保护

### 5.3 安全性
- **权限最小化：** 只请求必需的系统权限
- **数据本地化：** 所有数据存储在本地，不上传云端
- **紧急退出限制：** 每周最多3次，防止滥用

### 5.4 可维护性
- **代码注释率：** > 30%
- **单元测试覆盖率：** > 70%
- **模块化设计：** 功能模块独立，便于扩展

### 5.5 用户体验
- **易用性：** 首次使用有引导流程
- **可访问性：** 支持 VoiceOver
- **本地化：** 支持中文/英文

---

## 6. 开发计划

### 6.1 MVP 版本（v1.0）

**开发周期：** 4-6周

#### Week 1-2: 核心功能
- [ ] 空闲检测模块
- [ ] 全屏界面框架
- [ ] 基础数据模型
- [ ] 本地数据存储

#### Week 3-4: 功能完善
- [ ] 目标/项目管理
- [ ] "稍后提醒"阻碍机制
- [ ] 系统集成（EventKit）
- [ ] 设置面板

#### Week 5-6: 统计与优化
- [ ] 统计报告功能
- [ ] 数据可视化
- [ ] UI/UX 优化
- [ ] Bug 修复和测试

### 6.2 后续版本规划

**v1.1（+2周）**
- 配置文件导出/导入
- 菜单栏快捷操作
- 更多激励文案

**v1.2（+3周）**
- 专注模式（网站/应用屏蔽）
- 番茄钟集成
- 白噪音播放

**v2.0（+6周）**
- 时间追踪（自动检测应用使用）
- 成就徽章系统
- 第三方应用集成

---

## 7. 成功指标

### 7.1 核心指标
- **激活率：** 每周至少触发 3 次
- **开始工作率：** 选择"开始工作" ≥ 60%
- **目标完成率：** 设定的目标完成 ≥ 50%
- **持续使用：** 连续使用 4 周 ≥ 70% 用户

### 7.2 用户体验指标
- **紧急退出率：** < 10%（过高说明干扰太强）
- **设置调整频率：** 前两周 ≥ 2次（说明用户在适配）
- **统计报告查看率：** 每周至少查看 1 次 ≥ 50% 用户

---

## 8. 风险与挑战

### 8.1 技术风险
| 风险 | 影响 | 应对方案 |
|:---|:---|:---|
| macOS 系统权限限制 | 高 | 提前测试，准备降级方案 |
| 全屏窗口被系统绕过 | 中 | 多重拦截机制 |
| 性能问题（持续监控） | 中 | 优化检测频率，使用高效API |

### 8.2 用户体验风险
| 风险 | 影响 | 应对方案 |
|:---|:---|:---|
| 用户觉得太"强制"，卸载 | 高 | 提供灵活配置，降低强度 |
| 误触发导致不满 | 中 | 完善延迟触发和时间判断 |
| 统计数据不准确 | 低 | 允许手动修正数据 |

### 8.3 产品风险
| 风险 | 影响 | 应对方案 |
|:---|:---|:---|
| 用户养成"习惯性拖延" | 高 | 动态调整阻碍强度 |
| 用户找到绕过方法 | 中 | 限制紧急退出次数 |

---

## 9. 附录

### 9.1 默认激励文案库
```
1. "每一次选择都在塑造未来的你。今晚，选择成为更好的自己。"
2. "你不是没有时间，只是还没有开始。现在就是最好的时机。"
3. "成功者和普通人的区别，在于下班后的这几个小时。"
4. "今天的努力，是明天的从容。开始吧！"
5. "拖延一时爽，后悔一整年。行动起来！"
6. "你的竞争对手此刻正在学习，你呢？"
7. "专注2小时，胜过浑浑噩噩一整天。"
8. "每天进步1%，一年后你会强大37倍。"
9. "别让娱乐成为常态，让学习成为习惯。"
10. "未来的你会感谢现在努力的自己。"
```

### 9.2 拖延理由常见关键词（用于分析）
- 吃饭/晚饭
- 累/疲惫
- 消息/回复
- 休息/放松
- 临时/突然
- 家人/朋友

### 9.3 技术参考资料
- [IOKit Documentation](https://developer.apple.com/documentation/iokit)
- [EventKit Framework](https://developer.apple.com/documentation/eventkit)
- [App Sandbox](https://developer.apple.com/documentation/security/app_sandbox)
- [SwiftUI](https://developer.apple.com/xcode/swiftui/)

---

**文档版本：** v1.0  
**最后更新：** 2026-01-23  
**作者：** Focus Guardian Team  
**状态：** 待评审

---

这份PRD涵盖了你所有的需求！接下来你可以：
1. 审阅并提出修改意见
2. 确定优先级和MVP范围
3. 开始技术选型和原型开发

有什么需要调整或补充的吗？

---

Wang Macro: 先开始技术选型吧，我想先了解一下都是用哪些技术

---

Raycast AI: 好的！让我详细介绍一下技术选型方案。我会从多个维度分析，帮你做出最适合的选择。

---

# 技术选型方案

## 1. 开发语言选择

### 方案对比

| 语言 | 优势 | 劣势 | 推荐指数 |
|:---|:---|:---|:---|
| **Swift** | • 现代化语言，语法简洁<br>• Apple 官方主推<br>• 与 SwiftUI 完美集成<br>• 强类型安全<br>• 性能优秀 | • 学习曲线略陡<br>• 某些底层 API 文档较少 | ⭐⭐⭐⭐⭐ |
| **Objective-C** | • 成熟稳定<br>• 底层 API 文档丰富<br>• 性能可控 | • 语法冗长<br>• 不支持 SwiftUI<br>• 逐渐被淘汰 | ⭐⭐ |
| **Python** | • 快速原型开发<br>• 库丰富 | • 无法开发原生 UI<br>• 性能差<br>• 打包困难 | ⭐ |
| **Electron (JS/TS)** | • 跨平台<br>• Web 技术栈 | • 内存占用大<br>• 启动慢<br>• 不够原生 | ⭐⭐ |

**✅ 推荐：Swift**

**理由：**
- 本项目是纯 macOS 应用，Swift 是最佳选择
- 可以使用 SwiftUI 快速构建 UI
- 访问系统底层 API（IOKit、EventKit）非常方便
- 现代化的异步编程（async/await）
- Apple 生态的未来

---

## 2. UI 框架选择

### 方案 A：SwiftUI（推荐）

**适用场景：** 现代化 UI，快速开发

```swift
// SwiftUI 示例代码
struct WelcomeView: View {
    @State private var selectedGoal: Goal?
    
    var body: some View {
        VStack(spacing: 30) {
            // 标题
            Text("🌟 欢迎回来！现在是专注时刻 🌟")
                .font(.system(size: 36, weight: .bold))
            
            // 时间信息
            DateTimeView()
            
            // 激励文案
            MotivationalQuoteView()
            
            // 今日目标
            TodayGoalsView()
            
            // 操作按钮
            HStack(spacing: 20) {
                Button("📋 查看/设置今日目标") {
                    showGoalSetter()
                }
                .buttonStyle(PrimaryButtonStyle())
                
                Button("🚀 快速开始项目") {
                    showProjectList()
                }
                .buttonStyle(PrimaryButtonStyle())
            }
            
            Button("⏰ 稍后提醒") {
                showPostponeDialog()
            }
            .buttonStyle(SecondaryButtonStyle())
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.white)
    }
}
```

**优势：**
- ✅ 声明式语法，代码简洁
- ✅ 自动处理布局和状态
- ✅ 内置动画和过渡效果
- ✅ 与 Swift 生态完美集成
- ✅ 快速开发，易维护

**劣势：**
- ❌ 某些复杂交互需要 AppKit 桥接
- ❌ 全屏窗口控制需要额外处理
- ❌ 需要 macOS 11+ (Big Sur)

---

### 方案 B：AppKit（传统方案）

**适用场景：** 需要精细控制窗口行为

```swift
// AppKit 示例代码
class WelcomeViewController: NSViewController {
    
    private let titleLabel = NSTextField()
    private let goalButton = NSButton()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 手动布局
        titleLabel.stringValue = "🌟 欢迎回来！现在是专注时刻 🌟"
        titleLabel.font = NSFont.systemFont(ofSize: 36, weight: .bold)
        titleLabel.isBordered = false
        titleLabel.backgroundColor = .clear
        
        view.addSubview(titleLabel)
        
        // 手动设置约束
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            titleLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            titleLabel.topAnchor.constraint(equalTo: view.topAnchor, constant: 100)
        ])
    }
}
```

**优势：**
- ✅ 完全控制窗口行为
- ✅ 成熟稳定，文档丰富
- ✅ 支持更低版本 macOS

**劣势：**
- ❌ 代码冗长，开发慢
- ❌ 需要手动管理布局
- ❌ UI 更新需要手动处理

---

### 方案 C：SwiftUI + AppKit 混合（最佳方案）✅

**组合策略：**
- **SwiftUI：** 用于主要 UI 界面（欢迎界面、设置面板、统计报告）
- **AppKit：** 用于窗口管理、系统级交互、快捷键拦截

```swift
// 混合使用示例
import SwiftUI
import AppKit

// AppKit 窗口管理
class FullScreenWindowController: NSWindowController {
    
    init() {
        let window = FullScreenWindow()
        super.init(window: window)
        
        // 使用 SwiftUI View 作为内容
        let contentView = WelcomeView()
        window.contentView = NSHostingView(rootView: contentView)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// AppKit 自定义窗口
class FullScreenWindow: NSWindow {
    
    override init(contentRect: NSRect, styleMask: StyleMask, backing: BackingStoreType, defer flag: Bool) {
        super.init(
            contentRect: NSScreen.main?.frame ?? .zero,
            styleMask: [.borderless, .fullScreen],
            backing: .buffered,
            defer: false
        )
        
        self.level = .floating
        self.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]
        self.backgroundColor = .white
    }
    
    // 拦截所有快捷键
    override func performKeyEquivalent(with event: NSEvent) -> Bool {
        // 处理隐藏退出快捷键
        if isEmergencyExitShortcut(event) {
            handleEmergencyExit()
            return true
        }
        
        // 阻止其他快捷键
        return true
    }
    
    // 禁用关闭按钮
    override var canBecomeKey: Bool { true }
    override var canBecomeMain: Bool { true }
}

// SwiftUI 内容
struct WelcomeView: View {
    var body: some View {
        // SwiftUI 代码...
    }
}
```

**✅ 推荐这个混合方案！**

---

## 3. 核心功能技术实现

### 3.1 空闲时间检测

#### 方案 A：IOKit（推荐）✅

```swift
import IOKit.pwr_mgt

class IdleTimeDetector {
    
    func getSystemIdleTime() -> TimeInterval {
        var iterator: io_iterator_t = 0
        
        guard IOServiceGetMatchingServices(
            kIOMainPortDefault,
            IOServiceMatching("IOHIDSystem"),
            &iterator
        ) == KERN_SUCCESS else {
            return 0
        }
        
        defer { IOObjectRelease(iterator) }
        
        let entry = IOIteratorNext(iterator)
        guard entry != 0 else { return 0 }
        defer { IOObjectRelease(entry) }
        
        var property: Unmanaged<CFTypeRef>?
        guard IORegistryEntryCreateCFProperty(
            entry,
            "HIDIdleTime" as CFString,
            kCFAllocatorDefault,
            0,
            &property
        ) == KERN_SUCCESS else {
            return 0
        }
        
        let idleTime = property?.takeRetainedValue() as? NSNumber
        return TimeInterval((idleTime?.uint64Value ?? 0)) / 1_000_000_000
    }
}
```

**优势：**
- ✅ 系统级 API，准确可靠
- ✅ 低性能开销
- ✅ 无需额外权限

**劣势：**
- ❌ 只能检测键盘/鼠标，无法检测视频播放等

#### 方案 B：NSEvent 监听

```swift
// 不推荐：需要辅助功能权限，且性能开销大
```

---

### 3.2 系统集成（日历和提醒事项）

#### EventKit 框架（唯一方案）

```swift
import EventKit

class CalendarReminderManager {
    private let eventStore = EKEventStore()
    
    // 请求权限（macOS 14+ 需要异步）
    func requestAccess() async throws {
        let calendarGranted = try await eventStore.requestAccess(to: .event)
        let reminderGranted = try await eventStore.requestAccess(to: .reminder)
        
        guard calendarGranted && reminderGranted else {
            throw PermissionError.denied
        }
    }
    
    // 获取今日提醒事项
    func getTodayReminders() async -> [EKReminder] {
        let predicate = eventStore.predicateForReminders(in: nil)
        
        return await withCheckedContinuation { continuation in
            eventStore.fetchReminders(matching: predicate) { reminders in
                let today = Calendar.current.startOfDay(for: Date())
                let filtered = reminders?.filter { reminder in
                    guard let dueDate = reminder.dueDateComponents?.date else {
                        return false
                    }
                    return Calendar.current.isDate(dueDate, inSameDayAs: today)
                        && !reminder.isCompleted
                } ?? []
                
                continuation.resume(returning: filtered)
            }
        }
    }
    
    // 获取今日日历事件
    func getTodayEvents() -> [EKEvent] {
        let calendars = eventStore.calendars(for: .event)
        let today = Date()
        let startOfDay = Calendar.current.startOfDay(for: today)
        let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: startOfDay)!
        
        let predicate = eventStore.predicateForEvents(
            withStart: startOfDay,
            end: endOfDay,
            calendars: calendars
        )
        
        return eventStore.events(matching: predicate)
    }
}
```

**使用注意：**
- 需要在 `Info.plist` 添加权限说明
- macOS 13+ 权限请求更严格

```xml
<!-- Info.plist -->
<key>NSCalendarsUsageDescription</key>
<string>Focus Guardian 需要访问您的日历以显示今日事件</string>
<key>NSRemindersUsageDescription</key>
<string>Focus Guardian 需要访问您的提醒事项以显示今日待办</string>
```

---

### 3.3 数据持久化

#### 方案对比

| 方案 | 适用场景 | 优势 | 劣势 |
|:---|:---|:---|:---|
| **SwiftData** | 简单对象存储 | • 声明式<br>• 自动迁移<br>• 与 SwiftUI 集成 | • macOS 14+ 限制<br>• 相对较新 |
| **Core Data** | 复杂关系数据 | • 成熟稳定<br>• 功能强大<br>• 版本迁移完善 | • 配置复杂<br>• 学习曲线陡 |
| **SQLite** | 自定义查询 | • 灵活<br>• 跨平台 | • 需手动管理<br>• 无 ORM |
| **UserDefaults** | 配置存储 | • 简单易用 | • 只适合小数据 |
| **JSON 文件** | 简单数据 | • 易调试<br>• 可移植 | • 性能差<br>• 无事务 |

#### 推荐方案：SwiftData + UserDefaults ✅

```swift
// SwiftData 模型定义
import SwiftData

@Model
class UserSession {
    @Attribute(.unique) var id: UUID
    var triggerTime: Date
    var idleDuration: TimeInterval
    var choice: String
    var postponeReason: String?
    var project: Project?
    
    init(triggerTime: Date, idleDuration: TimeInterval) {
        self.id = UUID()
        self.triggerTime = triggerTime
        self.idleDuration = idleDuration
        self.choice = "pending"
    }
}

@Model
class Project {
    @Attribute(.unique) var id: UUID
    var title: String
    var type: String
    var createdAt: Date
    @Relationship(deleteRule: .cascade) var sessions: [UserSession]?
    
    init(title: String, type: String) {
        self.id = UUID()
        self.title = title
        self.type = type
        self.createdAt = Date()
    }
}

// 应用配置
import Foundation

@Observable
class AppSettings {
    var idleThreshold: TimeInterval {
        didSet { UserDefaults.standard.set(idleThreshold, forKey: "idleThreshold") }
    }
    var triggerDelay: TimeInterval {
        didSet { UserDefaults.standard.set(triggerDelay, forKey: "triggerDelay") }
    }
    
    init() {
        self.idleThreshold = UserDefaults.standard.double(forKey: "idleThreshold")
        if self.idleThreshold == 0 {
            self.idleThreshold = 8 * 3600 // 默认8小时
        }
        
        self.triggerDelay = UserDefaults.standard.double(forKey: "triggerDelay")
    }
}
```

**为什么这样组合？**
- SwiftData：存储会话、项目等结构化数据
- UserDefaults：存储配置项（简单键值对）

**如果需要兼容 macOS 13，使用 Core Data：**

```swift
// Core Data 实体定义（.xcdatamodeld）
// 需要通过 Xcode 数据模型编辑器创建

// 使用示例
import CoreData

class PersistenceController {
    static let shared = PersistenceController()
    
    let container: NSPersistentContainer
    
    init() {
        container = NSPersistentContainer(name: "FocusGuardian")
        container.loadPersistentStores { description, error in
            if let error = error {
                fatalError("Core Data failed: \(error)")
            }
        }
    }
    
    func save() {
        let context = container.viewContext
        if context.hasChanges {
            try? context.save()
        }
    }
}
```

---

### 3.4 定时任务和后台运行

#### 方案 A：Timer（简单场景）✅

```swift
import Foundation

class IdleMonitor {
    private var timer: Timer?
    private let detector = IdleTimeDetector()
    private let checkInterval: TimeInterval = 30 // 每30秒检查一次
    
    func startMonitoring() {
        timer = Timer.scheduledTimer(
            withTimeInterval: checkInterval,
            repeats: true
        ) { [weak self] _ in
            self?.checkIdleStatus()
        }
        
        // 保证在后台运行
        RunLoop.current.add(timer!, forMode: .common)
    }
    
    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
    }
    
    private func checkIdleStatus() {
        let idleTime = detector.getSystemIdleTime()
        // 处理逻辑...
    }
}
```

#### 方案 B：DispatchSourceTimer（高精度）

```swift
import Foundation

class PreciseIdleMonitor {
    private var timer: DispatchSourceTimer?
    
    func startMonitoring() {
        let queue = DispatchQueue(label: "com.focusguardian.idle-monitor")
        timer = DispatchSource.makeTimerSource(queue: queue)
        
        timer?.schedule(
            deadline: .now(),
            repeating: .seconds(30),
            leeway: .seconds(1)
        )
        
        timer?.setEventHandler { [weak self] in
            self?.checkIdleStatus()
        }
        
        timer?.resume()
    }
    
    func stopMonitoring() {
        timer?.cancel()
        timer = nil
    }
    
    private func checkIdleStatus() {
        // 检测逻辑
    }
}
```

**推荐：Timer** - 简单够用，易调试

---

### 3.5 本地通知

```swift
import UserNotifications

class NotificationManager {
    
    func requestAuthorization() async -> Bool {
        let center = UNUserNotificationCenter.current()
        do {
            return try await center.requestAuthorization(options: [.alert, .sound])
        } catch {
            return false
        }
    }
    
    func scheduleReminder(after interval: TimeInterval, title: String, body: String) {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = .default
        
        let trigger = UNTimeIntervalNotificationTrigger(
            timeInterval: interval,
            repeats: false
        )
        
        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: trigger
        )
        
        UNUserNotificationCenter.current().add(request)
    }
}
```

---

## 4. 数据可视化

### 推荐：Swift Charts ✅

```swift
import SwiftUI
import Charts

struct WeeklyReportView: View {
    let sessions: [UserSession]
    
    var body: some View {
        VStack {
            // 柱状图：每日工作时长
            Chart {
                ForEach(weeklyData, id: \.day) { data in
                    BarMark(
                        x: .value("Day", data.day),
                        y: .value("Hours", data.hours)
                    )
                    .foregroundStyle(by: .value("Type", data.type))
                }
            }
            .frame(height: 200)
            
            // 饼图：项目分布
            Chart {
                ForEach(projectData, id: \.name) { project in
                    SectorMark(
                        angle: .value("Duration", project.duration),
                        innerRadius: .ratio(0.5),
                        angularInset: 2
                    )
                    .foregroundStyle(by: .value("Project", project.name))
                }
            }
            .frame(height: 300)
        }
    }
}
```

**优势：**
- ✅ 原生框架，性能好
- ✅ 声明式语法
- ✅ 自动动画
- ✅ 支持丰富图表类型

**替代方案（如需更复杂图表）：**
- [DGCharts](https://github.com/danielgindi/Charts)（第三方）

---

## 5. 完整技术栈总结

### ✅ 最终推荐方案

```
┌─────────────────────────────────────────────────────────┐
│                   开发语言：Swift                        │
├─────────────────────────────────────────────────────────┤
│ UI 层                                                    │
│ • SwiftUI (主要 UI 界面)                                 │
│ • AppKit (窗口管理、快捷键拦截)                          │
├─────────────────────────────────────────────────────────┤
│ 核心功能                                                 │
│ • IOKit (空闲时间检测)                                   │
│ • EventKit (日历/提醒事项集成)                           │
│ • Timer (定时任务)                                       │
│ • UserNotifications (本地通知)                          │
├─────────────────────────────────────────────────────────┤
│ 数据层                                                   │
│ • SwiftData (macOS 14+) / Core Data (兼容)              │
│ • UserDefaults (配置存储)                               │
├─────────────────────────────────────────────────────────┤
│ 数据可视化                                               │
│ • Swift Charts                                          │
├─────────────────────────────────────────────────────────┤
│ 开发工具                                                 │
│ • Xcode 15+                                             │
│ • Git (版本控制)                                         │
├─────────────────────────────────────────────────────────┤
│ 测试                                                     │
│ • XCTest (单元测试)                                      │
│ • XCUITest (UI 测试)                                    │
└─────────────────────────────────────────────────────────┘
```

---

## 6. 项目结构建议

```
FocusGuardian/
├── App/
│   ├── FocusGuardianApp.swift          # 应用入口
│   └── AppDelegate.swift               # 应用代理
│
├── Core/
│   ├── IdleDetection/
│   │   ├── IdleTimeDetector.swift      # 空闲检测
│   │   └── IdleMonitor.swift           # 监控服务
│   │
│   ├── SystemIntegration/
│   │   ├── CalendarManager.swift       # 日历集成
│   │   └── ReminderManager.swift       # 提醒事项集成
│   │
│   └── WindowManagement/
│       ├── FullScreenWindow.swift      # 自定义窗口
│       └── WindowController.swift      # 窗口控制器
│
├── Models/
│   ├── UserSession.swift               # 会话模型
│   ├── Project.swift                   # 项目模型
│   └── AppSettings.swift               # 设置模型
│
├── Views/
│   ├── Welcome/
│   │   ├── WelcomeView.swift           # 欢迎界面
│   │   ├── GoalSetterView.swift        # 目标设置
│   │   └── PostponeDialogView.swift    # 稍后提醒对话框
│   │
│   ├── Settings/
│   │   └── SettingsView.swift          # 设置面板
│   │
│   └── Statistics/
│       ├── StatisticsView.swift        # 统计主界面
│       └── Charts/
│           ├── WeeklyChartView.swift   # 周报图表
│           └── ProjectPieChart.swift   # 项目饼图
│
├── ViewModels/
│   ├── WelcomeViewModel.swift
│   ├── SettingsViewModel.swift
│   └── StatisticsViewModel.swift
│
├── Services/
│   ├── DataService.swift               # 数据服务
│   ├── NotificationService.swift       # 通知服务
│   └── PersistenceController.swift     # 持久化控制
│
├── Utilities/
│   ├── Extensions/
│   │   ├── Date+Extensions.swift
│   │   └── View+Extensions.swift
│   │
│   └── Helpers/
│       └── TimeFormatter.swift
│
├── Resources/
│   ├── Assets.xcassets                 # 图片资源
│   ├── Localizable.strings             # 本地化
│   └── MotivationalQuotes.json         # 激励文案库
│
└── Tests/
    ├── UnitTests/
    └── UITests/
```

---

## 7. 依赖管理

### Swift Package Manager（推荐）✅

```swift
// Package.swift
dependencies: [
    // 如果需要第三方库
]
```

**优势：**
- ✅ Xcode 原生支持
- ✅ 无需额外工具
- ✅ 简单可靠

**本项目可能不需要第三方库**，Apple 原生框架已足够。

---

## 8. 开发环境要求

### 硬件
- Mac（Apple Silicon 或 Intel）
- 至少 8GB RAM
- 20GB 可用存储空间

### 软件
```
• macOS 14 Sonoma 或更高（开发机）
• Xcode 15.0+
• Git 2.30+
```

### 最低运行环境
```
• macOS 14 Sonoma（使用 SwiftData）
• 或 macOS 13 Ventura（使用 Core Data）
```

---

## 9. 关键代码示例

### 完整的应用入口

```swift
import SwiftUI
import SwiftData

@main
struct FocusGuardianApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        // 这里不创建主窗口，由 AppDelegate 控制
        Settings {
            SettingsView()
        }
    }
}

// AppDelegate 处理后台监控
class AppDelegate: NSObject, NSApplicationDelegate {
    private var idleMonitor: IdleMonitor?
    private var windowController: FullScreenWindowController?
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        // 隐藏 Dock 图标（可选）
        NSApp.setActivationPolicy(.accessory)
        
        // 启动空闲监控
        idleMonitor = IdleMonitor()
        idleMonitor?.onTrigger = { [weak self] in
            self?.showWelcomeScreen()
        }
        idleMonitor?.startMonitoring()
    }
    
    private func showWelcomeScreen() {
        DispatchQueue.main.async {
            self.windowController = FullScreenWindowController()
            self.windowController?.showWindow(nil)
            NSApp.activate(ignoringOtherApps: true)
        }
    }
}
```

---

## 10. 下一步行动

### 学习路线（如果你还不熟悉这些技术）

1. **Swift 基础**（1-2周）
   - [Swift 官方教程](https://docs.swift.org/swift-book/)
   - [100 Days of SwiftUI](https://www.hackingwithswift.com/100/swiftui)

2. **SwiftUI**（2-3周）
   - Apple 官方教程
   - 构建简单应用练手

3. **AppKit 窗口管理**（1周）
   - NSWindow 文档
   - 快捷键处理

4. **SwiftData / Core Data**（1周）
   - 数据建模
   - CRUD 操作

### 开发准备

1. **安装 Xcode**
   ```bash
   # 从 App Store 安装，或使用命令行工具
   xcode-select --install
   ```

2. **创建项目**
   - 打开 Xcode
   - File → New → Project
   - 选择 macOS → App
   - Interface: SwiftUI
   - Language: Swift

3. **配置权限**
   - Info.plist 添加日历/提醒权限说明

4. **开始第一个功能**
   - 建议从空闲检测开始

---

## 11. 技术风险评估

| 技术点 | 风险等级 | 说明 | 缓解方案 |
|:---|:---|:---|:---|
| IOKit 空闲检测 | 🟡 中 | API 文档较少 | 参考现有代码，充分测试 |
| 全屏窗口拦截 | 🟡 中 | macOS 安全限制 | 多重拦截机制 |
| EventKit 权限 | 🟢 低 | 用户可能拒绝 | 提供降级方案（手动输入） |
| SwiftData 稳定性 | 🟡 中 | 相对较新 | 做好数据备份 |
| 性能问题 | 🟢 低 | 持续监控开销 | 优化检测频率 |

---

## 总结

**核心技术栈：**
- ✅ **语言：Swift**
- ✅ **UI：SwiftUI + AppKit**
- ✅ **数据：SwiftData + UserDefaults**
- ✅ **系统：IOKit + EventKit**
- ✅ **可视化：Swift Charts**

**这套技术栈的优势：**
1. 🚀 **快速开发**：SwiftUI 大幅提升开发效率
2. 🎯 **原生体验**：100% Apple 技术，性能和体验最佳
3. 🔧 **易维护**：现代化代码，结构清晰
4. 📈 **可扩展**：后续功能易于添加

**需要的学习时间：**
- 如果你已经会 Swift：**1-2周**了解 SwiftUI 和 AppKit
- 如果是新手：**4-6周**学习 Swift + SwiftUI

你觉得这套技术方案如何？需要我详细讲解某个具体技术点吗？或者你想先从某个功能的实现代码开始？

---

Wang Macro: 使用 Tauri 可以实现全部功能吗？

---

Raycast AI: 好问题！让我详细分析一下使用 **Tauri** 是否能实现全部功能。

---

# Tauri 技术可行性分析

## 1. Tauri 简介

```
┌─────────────────────────────────────────┐
│           前端 (Web 技术)                │
│   HTML + CSS + JavaScript/TypeScript    │
│   React / Vue / Svelte / Vanilla        │
├─────────────────────────────────────────┤
│           Tauri API Bridge              │
├─────────────────────────────────────────┤
│           后端 (Rust)                    │
│   系统调用、文件操作、窗口管理           │
└─────────────────────────────────────────┘
```

**核心特点：**
- 前端使用 Web 技术（React、Vue 等）
- 后端使用 Rust
- 打包体积小（~3MB vs Electron 的 ~100MB）
- 性能接近原生
- 跨平台（Windows、macOS、Linux）

---

## 2. 功能实现可行性逐项分析

### ✅ 可以实现的功能

#### 2.1 空闲时间检测 ✅

**实现方式：** Rust 后端调用 macOS 系统 API

```rust
// src-tauri/src/idle_detection.rs
use std::time::Duration;

#[cfg(target_os = "macos")]
pub fn get_idle_time() -> Result<Duration, String> {
    use core_foundation::base::TCFType;
    use core_graphics::display::CGDisplay;
    
    unsafe {
        // 通过 Core Graphics 获取空闲时间
        let idle_time = CGDisplay::idle_time();
        Ok(Duration::from_secs_f64(idle_time))
    }
}

// 暴露给前端
#[tauri::command]
fn get_system_idle_time() -> f64 {
    match get_idle_time() {
        Ok(duration) => duration.as_secs_f64(),
        Err(_) => 0.0,
    }
}
```

**前端调用：**
```typescript
import { invoke } from '@tauri-apps/api/tauri';

const idleTime = await invoke<number>('get_system_idle_time');
console.log(`Idle for ${idleTime} seconds`);
```

**可行性：✅ 完全可以**

---

#### 2.2 全屏窗口 ✅

**Tauri 窗口 API：**

```typescript
import { appWindow } from '@tauri-apps/api/window';

// 全屏
await appWindow.setFullscreen(true);

// 置顶
await appWindow.setAlwaysOnTop(true);

// 无边框
await appWindow.setDecorations(false);

// 设置尺寸为屏幕大小
const monitor = await appWindow.currentMonitor();
await appWindow.setSize(monitor.size);
```

**Rust 配置：**
```rust
// src-tauri/tauri.conf.json
{
  "tauri": {
    "windows": [{
      "fullscreen": true,
      "decorations": false,
      "alwaysOnTop": true,
      "resizable": false,
      "skipTaskbar": true
    }]
  }
}
```

**可行性：✅ 完全可以**

---

#### 2.3 UI 界面 ✅

**前端完全自由，可以使用现代 Web 技术：**

```tsx
// 使用 React + TailwindCSS 示例
import React from 'react';

export function WelcomeScreen() {
  return (
    <div className="min-h-screen bg-white flex flex-col items-center justify-center">
      <h1 className="text-4xl font-bold mb-8">
        🌟 欢迎回来！现在是专注时刻 🌟
      </h1>
      
      <div className="text-xl mb-4">
        📅 {new Date().toLocaleDateString('zh-CN')}
      </div>
      
      <div className="mt-8 space-y-4">
        <button 
          className="px-8 py-4 bg-blue-500 text-white rounded-lg"
          onClick={handleStartWork}
        >
          📋 查看/设置今日目标
        </button>
        
        <button 
          className="px-8 py-4 bg-orange-500 text-white rounded-lg"
          onClick={handleQuickStart}
        >
          🚀 快速开始项目
        </button>
      </div>
    </div>
  );
}
```

**优势：**
- 🎨 UI 开发速度快
- 🔧 大量现成组件库（Ant Design、Material-UI 等）
- 📊 图表库丰富（ECharts、Chart.js、D3.js）

**可行性：✅ 完全可以，甚至更快**

---

#### 2.4 数据存储 ✅

**方案选择：**

**选项 A：使用 Tauri 的文件系统 API + SQLite**

```rust
// Rust 后端使用 SQLite
use rusqlite::{Connection, Result};

#[tauri::command]
fn save_session(session_data: SessionData) -> Result<(), String> {
    let conn = Connection::open("data.db")
        .map_err(|e| e.to_string())?;
    
    conn.execute(
        "INSERT INTO sessions (trigger_time, choice, project_id) VALUES (?1, ?2, ?3)",
        params![session_data.trigger_time, session_data.choice, session_data.project_id],
    ).map_err(|e| e.to_string())?;
    
    Ok(())
}
```

**选项 B：使用 Tauri Store 插件**

```typescript
import { Store } from 'tauri-plugin-store-api';

const store = new Store('.settings.dat');

// 保存配置
await store.set('idleThreshold', 28800);
await store.save();

// 读取配置
const threshold = await store.get('idleThreshold');
```

**可行性：✅ 完全可以**

---

#### 2.5 定时任务和后台运行 ✅

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

pub fn start_idle_monitoring(app_handle: tauri::AppHandle) {
    thread::spawn(move || {
        loop {
            thread::sleep(Duration::from_secs(30));
            
            let idle_time = get_idle_time().unwrap_or(Duration::ZERO);
            
            if idle_time.as_secs() > 28800 {
                // 触发前端事件
                app_handle.emit_all("idle-detected", idle_time.as_secs()).unwrap();
            }
        }
    });
}
```

```typescript
// 前端监听
import { listen } from '@tauri-apps/api/event';

listen<number>('idle-detected', (event) => {
  console.log(`Idle detected: ${event.payload} seconds`);
  showWelcomeScreen();
});
```

**可行性：✅ 完全可以**

---

#### 2.6 统计图表 ✅

**使用成熟的 Web 图表库：**

```tsx
import { Line, Pie } from 'react-chartjs-2';

export function StatisticsView() {
  return (
    <div>
      {/* 周报折线图 */}
      <Line 
        data={{
          labels: ['周一', '周二', '周三', '周四', '周五'],
          datasets: [{
            label: '工作时长（小时）',
            data: [2.5, 3, 1.5, 4, 2]
          }]
        }}
      />
      
      {/* 项目分布饼图 */}
      <Pie
        data={{
          labels: ['Python 开发', 'SwiftUI 学习', '博客写作'],
          datasets: [{
            data: [50, 28, 22]
          }]
        }}
      />
    </div>
  );
}
```

**可行性：✅ 完全可以，选择更多**

---

### ⚠️ 有限制的功能

#### 2.7 快捷键拦截 ⚠️

**Tauri 支持注册全局快捷键：**

```rust
use tauri::GlobalShortcutManager;

fn setup_shortcuts(app: &mut App) -> Result<(), Box<dyn std::error::Error>> {
    let mut shortcuts = app.global_shortcut_manager();
    
    // 注册快捷键
    shortcuts.register("CommandOrControl+Shift+E", || {
        println!("Emergency exit triggered!");
    })?;
    
    Ok(())
}
```

**但是！有限制：**

❌ **无法阻止系统级快捷键**
- 无法阻止 `Cmd+Q`（退出应用）
- 无法阻止 `Cmd+W`（关闭窗口）
- 无法阻止 `Cmd+H`（隐藏窗口）
- 无法阻止 `Cmd+Tab`（切换应用）

**这是最大的问题！** 你的需求中要求"全屏不可关闭"，但 Tauri 无法完全阻止用户退出。

**变通方案：**
- 监听窗口关闭事件，弹出确认对话框
- 隐藏关闭按钮（已经无边框）
- 禁用右键菜单

```rust
use tauri::Manager;

fn prevent_close(app: &tauri::AppHandle) {
    let window = app.get_window("main").unwrap();
    
    window.on_window_event(|event| {
        if let tauri::WindowEvent::CloseRequested { api, .. } = event {
            // 阻止关闭，显示对话框
            api.prevent_close();
            // 显示"真的要退出吗？"对话框
        }
    });
}
```

**可行性：⚠️ 部分可以，但无法完全阻止强制退出**

---

### ❌ 难以实现的功能

#### 2.8 系统集成（日历和提醒事项）❌

**这是 Tauri 的最大短板！**

**问题：**
- macOS 的 EventKit 是 Objective-C/Swift 框架
- Tauri 的 Rust 后端无法直接调用
- 需要额外的 FFI（外部函数接口）桥接

**理论上的解决方案：**

```rust
// 需要手动创建 Objective-C 绑定
#[link(name = "EventKit", kind = "framework")]
extern "C" {
    // 手动声明 EventKit 函数...
    // 这非常复杂且容易出错
}
```

**或者使用第三方命令行工具：**

```rust
use std::process::Command;

#[tauri::command]
fn get_calendar_events() -> Result<String, String> {
    // 使用 macOS 的 osascript 读取日历
    let output = Command::new("osascript")
        .arg("-e")
        .arg(r#"
            tell application "Calendar"
                get name of every event of calendar "Work" whose start date is today
            end tell
        "#)
        .output()
        .map_err(|e| e.to_string())?;
    
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
```

**问题：**
- ❌ 需要用户授予"自动化"权限
- ❌ AppleScript 功能有限，无法完整访问 EventKit
- ❌ 性能差，不可靠

**可行性：❌ 非常困难，不推荐**

---

## 3. Tauri vs Swift 原生对比

| 功能 | Swift 原生 | Tauri | 说明 |
|:---|:---:|:---:|:---|
| 空闲检测 | ✅ | ✅ | 都可以调用系统 API |
| 全屏窗口 | ✅ | ✅ | 都支持 |
| UI 开发速度 | ⚠️ | ✅✅ | Tauri 更快（Web 技术） |
| UI 组件库 | ⚠️ | ✅✅ | Web 生态更丰富 |
| 快捷键拦截 | ✅✅ | ⚠️ | Swift 可完全控制 |
| 系统集成 | ✅✅ | ❌ | Swift 原生支持 EventKit |
| 数据存储 | ✅ | ✅ | 都可以 |
| 图表可视化 | ✅ | ✅✅ | Web 图表库更多 |
| 打包体积 | ~5MB | ~3MB | Tauri 更小 |
| 性能 | ✅✅ | ✅ | Swift 稍好 |
| 学习曲线 | ⚠️ | ✅ | 取决于背景 |
| 跨平台 | ❌ | ✅ | Tauri 可跨平台 |
| 原生体验 | ✅✅ | ⚠️ | Swift 更原生 |

---

## 4. 具体实现难度评估

### 核心需求实现难度

| 需求 | Swift | Tauri | 推荐 |
|:---|:---:|:---:|:---:|
| 空闲检测触发 | 🟢 简单 | 🟢 简单 | 平手 |
| 全屏不可关闭 | 🟢 简单 | 🟡 中等 | Swift |
| 集成日历/提醒 | 🟢 简单 | 🔴 困难 | Swift |
| 设置今日目标 | 🟢 简单 | 🟢 简单 | 平手 |
| "稍后提醒"阻碍 | 🟢 简单 | 🟢 简单 | 平手 |
| 统计报告 | 🟡 中等 | 🟢 简单 | Tauri |
| 数据可视化 | 🟡 中等 | 🟢 简单 | Tauri |

---

## 5. Tauri 完整实现方案

### 如果选择 Tauri，技术栈如下：

```
前端：
├── React 18 + TypeScript
├── TailwindCSS（样式）
├── React Query（状态管理）
├── Chart.js / Recharts（图表）
└── Framer Motion（动画）

后端（Rust）：
├── Tauri Core
├── rusqlite（数据库）
├── serde（序列化）
├── tokio（异步运行时）
└── core-graphics-sys（macOS API）

工具：
├── Vite（构建工具）
├── pnpm/npm（包管理）
└── Rust Cargo
```

### 项目结构

```
focus-guardian/
├── src/                    # 前端代码
│   ├── App.tsx
│   ├── views/
│   │   ├── WelcomeScreen.tsx
│   │   ├── GoalSetter.tsx
│   │   ├── PostponeDialog.tsx
│   │   └── Statistics.tsx
│   └── hooks/
│       └── useIdleDetection.ts
│
├── src-tauri/              # Rust 后端
│   ├── src/
│   │   ├── main.rs
│   │   ├── idle_detection.rs
│   │   ├── database.rs
│   │   └── commands.rs
│   ├── Cargo.toml
│   └── tauri.conf.json
│
└── package.json
```

### 示例代码

**前端 Hook：**
```typescript
// src/hooks/useIdleDetection.ts
import { useState, useEffect } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { listen } from '@tauri-apps/api/event';

export function useIdleDetection(threshold: number) {
  const [isIdle, setIsIdle] = useState(false);
  
  useEffect(() => {
    // 监听后端事件
    const unlisten = listen('idle-threshold-exceeded', () => {
      setIsIdle(true);
    });
    
    return () => {
      unlisten.then(fn => fn());
    };
  }, [threshold]);
  
  return { isIdle, setIsIdle };
}
```

**Rust 后端：**
```rust
// src-tauri/src/main.rs
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod idle_detection;
mod database;

use tauri::Manager;

#[tauri::command]
fn get_idle_time() -> f64 {
    idle_detection::get_system_idle_time()
}

#[tauri::command]
fn save_session(choice: String, reason: Option<String>) -> Result<(), String> {
    database::save_session(choice, reason)
}

fn main() {
    tauri::Builder::default()
        .setup(|app| {
            // 启动后台监控
            let app_handle = app.handle();
            std::thread::spawn(move || {
                idle_detection::start_monitoring(app_handle);
            });
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            get_idle_time,
            save_session
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

---

## 6. 关键问题解决方案

### 问题1：如何处理日历/提醒事项集成？

**方案 A：放弃原生集成，手动输入** ✅
```tsx
// 用户手动输入今日目标
<input 
  placeholder="输入今日目标"
  onChange={(e) => setGoal(e.target.value)}
/>
```

**方案 B：使用 AppleScript（不推荐）** ⚠️
```rust
// 功能有限且不稳定
fn get_reminders_via_applescript() {
    // ...
}
```

**方案 C：集成第三方服务（未来扩展）** 🔮
- 集成 Notion API
- 集成 Todoist API
- 集成 Google Calendar API

**推荐：方案 A（MVP）→ 方案 C（未来）**

---

### 问题2：如何防止用户关闭？

**Tauri 的限制：**
- ❌ 无法阻止 `Force Quit`（强制退出）
- ⚠️ 可以阻止常规关闭

**实现方案：**
```rust
window.on_window_event(|event| {
    match event {
        WindowEvent::CloseRequested { api, .. } => {
            api.prevent_close();
            // 显示确认对话框
            show_close_confirmation_dialog();
        }
        _ => {}
    }
});
```

**配合前端：**
```typescript
// 禁用浏览器默认行为
window.addEventListener('beforeunload', (e) => {
  e.preventDefault();
  e.returnValue = '';
});
```

**实际效果：**
- ✅ 可以阻止点击关闭按钮
- ✅ 可以阻止 Cmd+W
- ❌ 无法阻止 Cmd+Q 或 Force Quit

**这比 Swift 原生方案弱！**

---

## 7. 最终建议

### 如果你的情况符合以下条件，可以选 Tauri：

✅ **可以选 Tauri 的情况：**
1. 你已经熟悉 Web 开发（React/Vue/JS）
2. 你对 Rust 感兴趣或已有基础
3. 可以接受**不集成系统日历/提醒**（手动输入目标）
4. 可以接受"强制关闭"防护比 Swift 弱
5. 未来可能需要跨平台（Windows/Linux）
6. 看重开发速度（UI 部分更快）

❌ **必须选 Swift 的情况：**
1. **必须集成系统日历和提醒事项**（这是核心需求）
2. 必须完全阻止用户关闭（包括系统级快捷键）
3. 只需要 macOS，不需要跨平台
4. 想要 100% 原生体验

---

## 8. 对比总结

### 开发效率
- **Tauri：** ⭐⭐⭐⭐⭐（UI 开发快）
- **Swift：** ⭐⭐⭐（SwiftUI 学习曲线）

### 功能完整度
- **Tauri：** ⭐⭐⭐（缺少日历集成）
- **Swift：** ⭐⭐⭐⭐⭐（完整支持）

### 用户体验
- **Tauri：** ⭐⭐⭐⭐（接近原生）
- **Swift：** ⭐⭐⭐⭐⭐（100% 原生）

### 维护成本
- **Tauri：** ⭐⭐⭐⭐（Web 生态成熟）
- **Swift：** ⭐⭐⭐⭐（Apple 生态稳定）

---

## 9. 我的最终建议

**根据你的 PRD 需求：**

### 推荐：**Swift 原生** ✅

**理由：**
1. 🎯 **你明确要求集成系统日历和提醒事项**（Q5的回答）
   - 这是 Tauri 的硬伤
   
2. 🔒 **你要求全屏不可关闭，设置重重阻碍**
   - Swift 可以完全控制，Tauri 有限制
   
3. 📱 **纯 macOS 应用，不需要跨平台**
   - Swift 没有劣势

4. ⚡ **性能和原生体验更重要**

**但是，如果：**
- 你可以放弃日历/提醒集成 → 考虑 Tauri
- 你 Web 开发经验丰富，Swift 零基础 → 考虑 Tauri
- 未来要支持 Windows → 考虑 Tauri

---

## 10. 混合方案（最佳）

**第三种选择：Tauri + Swift 插件** 🤔

Tauri 支持自定义插件，可以用 Swift 编写原生模块：

```rust
// 调用 Swift 编写的插件
#[tauri::command]
fn get_calendar_events() -> Vec<Event> {
    // 通过 FFI 调用 Swift 代码
    swift_calendar_plugin::get_events()
}
```

但这样做：
- ❌ 复杂度大增
- ❌ 失去了 Tauri 的简洁性
- ⚠️ 不如直接用 Swift

---

你想要哪种方案？我可以帮你：
1. 深入 Swift 方案，提供完整代码示例
2. 尝试 Tauri 方案，接受日历集成的限制
3. 先做技术原型，实际测试两种方案

你的选择是？

---

Wang Macro: 日历/提醒事项没有API 或者接口可以实现吗？

---

Raycast AI: 非常好的问题！让我详细分析一下 macOS 上访问日历和提醒事项的所有可能方式。

---

# macOS 日历/提醒事项访问方案

## 1. 官方 API：EventKit Framework ✅

### 这是唯一的官方方式

**支持的语言：**
- ✅ Objective-C
- ✅ Swift
- ❌ 其他语言（需要桥接）

**功能：**
```swift
import EventKit

let eventStore = EKEventStore()

// 请求权限
await eventStore.requestAccess(to: .event)  // 日历
await eventStore.requestAccess(to: .reminder)  // 提醒事项

// 读取今日事件
let events = eventStore.events(matching: predicate)

// 读取提醒事项
eventStore.fetchReminders(matching: predicate) { reminders in
    // 处理提醒事项
}
```

**关键信息：**
- 🔒 需要用户授权（隐私权限）
- 📱 完整的 CRUD 操作
- 🎯 可以筛选、搜索
- 🔄 实时更新

---

## 2. 使用 AppleScript 访问

### 通过脚本自动化访问日历和提醒事项

**日历（Calendar.app）：**

```applescript
-- 获取今日事件
tell application "Calendar"
    set todayStart to (current date)
    set time of todayStart to 0
    
    set todayEnd to todayStart + (1 * days)
    
    set todayEvents to {}
    repeat with cal in calendars
        set calEvents to (every event of cal whose start date ≥ todayStart and start date < todayEnd)
        set todayEvents to todayEvents & calEvents
    end repeat
    
    set eventList to {}
    repeat with evt in todayEvents
        set eventInfo to {summary:(summary of evt), startDate:(start date of evt)}
        set end of eventList to eventInfo
    end repeat
    
    return eventList
end tell
```

**提醒事项（Reminders.app）：**

```applescript
-- 获取今日到期的提醒
tell application "Reminders"
    set todayReminders to {}
    repeat with reminderList in lists
        set allReminders to (every reminder of reminderList whose completed is false)
        repeat with rem in allReminders
            if due date of rem is not missing value then
                set dueDate to due date of rem
                -- 判断是否是今天
                if (dueDate ≥ (current date) - (1 * days)) and (dueDate < (current date) + (1 * days)) then
                    set end of todayReminders to {name:(name of rem), dueDate:dueDate}
                end if
            end if
        end repeat
    end repeat
    
    return todayReminders
end tell
```

### 在 Tauri 中调用 AppleScript

**方法 1：通过 Rust 执行命令**

```rust
use std::process::Command;

#[tauri::command]
fn get_calendar_events() -> Result<String, String> {
    let script = r#"
        tell application "Calendar"
            set todayEvents to every event of calendar "Work" whose start date is today
            set eventNames to {}
            repeat with evt in todayEvents
                set end of eventNames to summary of evt
            end repeat
            return eventNames
        end tell
    "#;
    
    let output = Command::new("osascript")
        .arg("-e")
        .arg(script)
        .output()
        .map_err(|e| e.to_string())?;
    
    if output.status.success() {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    } else {
        Err(String::from_utf8_lossy(&output.stderr).to_string())
    }
}

#[tauri::command]
fn get_reminders() -> Result<Vec<ReminderInfo>, String> {
    let script = r#"
        tell application "Reminders"
            set output to ""
            repeat with reminderList in lists
                set allReminders to (every reminder of reminderList whose completed is false)
                repeat with rem in allReminders
                    set output to output & (name of rem) & "|"
                    if due date of rem is not missing value then
                        set output to output & (due date of rem as string)
                    end if
                    set output to output & "\n"
                end repeat
            end repeat
            return output
        end tell
    "#;
    
    let output = Command::new("osascript")
        .arg("-e")
        .arg(script)
        .output()
        .map_err(|e| e.to_string())?;
    
    let result = String::from_utf8_lossy(&output.stdout);
    
    // 解析结果
    let reminders = parse_reminder_output(&result);
    Ok(reminders)
}
```

**优点：**
- ✅ 可以在任何语言中使用（包括 Rust/Tauri）
- ✅ 不需要编写 Objective-C/Swift 桥接
- ✅ 可以访问日历和提醒事项

**缺点：**
- ⚠️ 需要用户授予"自动化"权限（Automation）
- ⚠️ 性能较差（每次调用都启动 osascript 进程）
- ⚠️ 错误处理复杂
- ⚠️ 返回的数据格式需要自己解析
- ⚠️ AppleScript 功能有限，某些高级特性无法使用

---

## 3. 使用命令行工具

### icalBuddy（第三方工具）

[icalBuddy](https://hasseg.org/icalBuddy/) 是一个命令行工具，可以读取 macOS 日历。

**安装：**
```bash
brew install ical-buddy
```

**使用：**
```bash
# 获取今日事件
icalBuddy -n -f eventsToday

# 获取未完成的提醒
icalBuddy -n -f uncompletedTasks
```

**在 Tauri 中调用：**

```rust
#[tauri::command]
fn get_today_events() -> Result<String, String> {
    let output = Command::new("icalBuddy")
        .args(&["-n", "-f", "eventsToday"])
        .output()
        .map_err(|e| e.to_string())?;
    
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
```

**优点：**
- ✅ 简单易用
- ✅ 输出格式友好
- ✅ 支持多种筛选选项

**缺点：**
- ⚠️ 需要用户安装第三方工具
- ⚠️ 只读操作，无法创建/修改
- ⚠️ 依赖外部程序

---

## 4. 直接访问数据库（不推荐）❌

### 日历数据存储位置

macOS 将日历数据存储在 SQLite 数据库中：

```
~/Library/Calendars/Calendar.sqlitedb
```

**理论上可以直接读取：**

```rust
use rusqlite::{Connection, Result};

fn read_calendar_db() -> Result<Vec<Event>> {
    let db_path = format!(
        "{}/Library/Calendars/Calendar.sqlitedb",
        std::env::var("HOME").unwrap()
    );
    
    let conn = Connection::open(db_path)?;
    
    let mut stmt = conn.prepare("SELECT * FROM CalendarItem")?;
    // ...
}
```

**为什么不推荐：**
- ❌ 违反 macOS 沙盒规则
- ❌ 数据库结构未公开，可能随版本变化
- ❌ 可能导致数据损坏
- ❌ 应用无法上架 App Store
- ❌ 绕过权限系统，有安全风险

**🚫 千万不要用这个方法！**

---

## 5. 云服务 API

### iCloud Calendar API（间接方式）

**通过 CalDAV 协议：**

```typescript
// 需要用户的 iCloud 账号和应用专用密码
const caldavUrl = 'https://caldav.icloud.com/';

// 使用 CalDAV 客户端库
import { DAVClient } from 'tsdav';

const client = new DAVClient({
  serverUrl: caldavUrl,
  credentials: {
    username: 'user@icloud.com',
    password: 'app-specific-password'
  },
  authMethod: 'Basic',
  defaultAccountType: 'caldav'
});

await client.login();
const calendars = await client.fetchCalendars();
```

**优点：**
- ✅ 跨平台
- ✅ 可以同步云端数据

**缺点：**
- ❌ 需要用户提供 iCloud 账号密码
- ❌ 需要生成应用专用密码
- ❌ 复杂度高
- ❌ 无法访问本地日历
- ❌ 需要网络连接

---

## 6. Tauri 方案对比总结

### 可行方案对比

| 方案 | 可行性 | 难度 | 权限要求 | 功能完整度 | 推荐指数 |
|:---|:---:|:---:|:---|:---:|:---:|
| EventKit (Swift) | ✅ | 🟢 低 | 日历/提醒 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| AppleScript | ✅ | 🟡 中 | 自动化 | ⭐⭐⭐ | ⭐⭐⭐ |
| icalBuddy | ✅ | 🟢 低 | 无（需用户安装） | ⭐⭐ | ⭐⭐ |
| 直接读数据库 | ❌ | 🔴 高 | 违规 | ⭐⭐⭐⭐ | ❌ |
| 云服务 API | ⚠️ | 🔴 高 | 需账号密码 | ⭐⭐⭐⭐ | ⭐ |

---

## 7. Tauri 的实际可行方案

### ✅ 推荐方案：AppleScript

**完整实现示例：**

```rust
// src-tauri/src/calendar.rs
use serde::{Deserialize, Serialize};
use std::process::Command;

#[derive(Debug, Serialize, Deserialize)]
pub struct CalendarEvent {
    pub title: String,
    pub start_date: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Reminder {
    pub title: String,
    pub due_date: Option<String>,
    pub completed: bool,
}

pub fn get_today_calendar_events() -> Result<Vec<CalendarEvent>, String> {
    let script = r#"
        use framework "Foundation"
        use framework "EventKit"
        
        set eventStore to current application's EKEventStore's alloc()'s init()
        
        -- 请求权限（在 Tauri 中需要提前请求）
        set startDate to current application's NSDate's |date|()
        set endDate to startDate's dateByAddingTimeInterval:86400
        
        set calendars to eventStore's calendarsForEntityType:0
        set predicate to eventStore's predicateForEventsWithStartDate:startDate endDate:endDate calendars:calendars
        
        set events to eventStore's eventsMatchingPredicate:predicate
        
        set output to ""
        repeat with evt in events
            set eventTitle to evt's title() as text
            set eventStart to evt's startDate() as text
            set output to output & eventTitle & "|" & eventStart & "\n"
        end repeat
        
        return output
    "#;
    
    let output = Command::new("osascript")
        .arg("-l")
        .arg("JavaScript")  // 或使用 AppleScript
        .arg("-e")
        .arg(script)
        .output()
        .map_err(|e| format!("Failed to execute script: {}", e))?;
    
    if !output.status.success() {
        return Err(String::from_utf8_lossy(&output.stderr).to_string());
    }
    
    let result = String::from_utf8_lossy(&output.stdout);
    let events = parse_events(&result);
    
    Ok(events)
}

pub fn get_today_reminders() -> Result<Vec<Reminder>, String> {
    let script = r#"
        tell application "Reminders"
            set output to ""
            set todayStart to (current date)
            set time of todayStart to 0
            set todayEnd to todayStart + (1 * days)
            
            repeat with reminderList in lists
                set listReminders to (every reminder of reminderList)
                repeat with rem in listReminders
                    if completed of rem is false then
                        set remTitle to name of rem
                        set remDue to ""
                        if due date of rem is not missing value then
                            set dueDate to due date of rem
                            if dueDate ≥ todayStart and dueDate < todayEnd then
                                set remDue to dueDate as string
                            end if
                        end if
                        if remDue is not "" or due date of rem is missing value then
                            set output to output & remTitle & "|" & remDue & "\n"
                        end if
                    end if
                end repeat
            end repeat
            
            return output
        end tell
    "#;
    
    let output = Command::new("osascript")
        .arg("-e")
        .arg(script)
        .output()
        .map_err(|e| format!("Failed to execute script: {}", e))?;
    
    if !output.status.success() {
        return Err(String::from_utf8_lossy(&output.stderr).to_string());
    }
    
    let result = String::from_utf8_lossy(&output.stdout);
    let reminders = parse_reminders(&result);
    
    Ok(reminders)
}

fn parse_events(output: &str) -> Vec<CalendarEvent> {
    output
        .lines()
        .filter(|line| !line.trim().is_empty())
        .filter_map(|line| {
            let parts: Vec<&str> = line.split('|').collect();
            if parts.len() >= 2 {
                Some(CalendarEvent {
                    title: parts[0].to_string(),
                    start_date: parts[1].to_string(),
                })
            } else {
                None
            }
        })
        .collect()
}

fn parse_reminders(output: &str) -> Vec<Reminder> {
    output
        .lines()
        .filter(|line| !line.trim().is_empty())
        .filter_map(|line| {
            let parts: Vec<&str> = line.split('|').collect();
            if !parts.is_empty() {
                Some(Reminder {
                    title: parts[0].to_string(),
                    due_date: if parts.len() > 1 && !parts[1].is_empty() {
                        Some(parts[1].to_string())
                    } else {
                        None
                    },
                    completed: false,
                })
            } else {
                None
            }
        })
        .collect()
}

// Tauri Commands
#[tauri::command]
pub fn fetch_calendar_events() -> Result<Vec<CalendarEvent>, String> {
    get_today_calendar_events()
}

#[tauri::command]
pub fn fetch_reminders() -> Result<Vec<Reminder>, String> {
    get_today_reminders()
}
```

**前端调用：**

```typescript
// src/hooks/useCalendarIntegration.ts
import { invoke } from '@tauri-apps/api/tauri';

interface CalendarEvent {
  title: string;
  start_date: string;
}

interface Reminder {
  title: string;
  due_date?: string;
  completed: boolean;
}

export function useCalendarIntegration() {
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [reminders, setReminders] = useState<Reminder[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const [eventsData, remindersData] = await Promise.all([
        invoke<CalendarEvent[]>('fetch_calendar_events'),
        invoke<Reminder[]>('fetch_reminders')
      ]);
      
      setEvents(eventsData);
      setReminders(remindersData);
    } catch (err) {
      setError(err as string);
      console.error('Failed to fetch calendar data:', err);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchData();
  }, []);
  
  return { events, reminders, loading, error, refetch: fetchData };
}
```

**使用：**

```tsx
// src/views/WelcomeScreen.tsx
import { useCalendarIntegration } from '../hooks/useCalendarIntegration';

export function WelcomeScreen() {
  const { events, reminders, loading, error } = useCalendarIntegration();
  
  return (
    <div>
      <h2>📅 今日日程</h2>
      {loading && <p>加载中...</p>}
      {error && <p className="text-red-500">需要授予自动化权限: {error}</p>}
      
      <ul>
        {events.map((event, i) => (
          <li key={i}>
            {event.title} - {event.start_date}
          </li>
        ))}
      </ul>
      
      <h2>✅ 今日待办</h2>
      <ul>
        {reminders.map((reminder, i) => (
          <li key={i}>
            □ {reminder.title}
            {reminder.due_date && ` (${reminder.due_date})`}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## 8. 权限配置

### Tauri 需要的权限配置

**Info.plist（需要添加）：**

```xml
<!-- src-tauri/Info.plist -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSAppleEventsUsageDescription</key>
    <string>Focus Guardian 需要访问日历和提醒事项以显示您的今日计划</string>
    
    <key>NSCalendarsUsageDescription</key>
    <string>用于显示您的今日日程</string>
    
    <key>NSRemindersUsageDescription</key>
    <string>用于显示您的今日待办事项</string>
</dict>
</plist>
```

**tauri.conf.json：**

```json
{
  "tauri": {
    "bundle": {
      "macOS": {
        "entitlements": "entitlements.plist",
        "exceptionDomain": "",
        "frameworks": [],
        "providerShortName": null,
        "signingIdentity": null
      }
    }
  }
}
```

**entitlements.plist：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.automation.apple-events</key>
    <true/>
    
    <key>com.apple.security.personal-information.calendars</key>
    <true/>
</dict>
</plist>
```

---

## 9. 实际效果对比

### EventKit (Swift) vs AppleScript (Tauri)

**功能对比：**

| 功能 | EventKit | AppleScript |
|:---|:---:|:---:|
| 读取日历事件 | ✅ | ✅ |
| 读取提醒事项 | ✅ | ✅ |
| 创建事件 | ✅ | ⚠️ 有限 |
| 修改事件 | ✅ | ⚠️ 有限 |
| 删除事件 | ✅ | ⚠️ 有限 |
| 实时监听变化 | ✅ | ❌ |
| 性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 可靠性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 权限请求 | 自动 | 需要手动授权 |

**性能测试（估算）：**

```
EventKit 读取 100 个事件：  ~50ms
AppleScript 读取 100 个事件：~500-1000ms
```

---

## 10. 最终建议

### 对于你的项目：

#### 方案 A：Swift 原生（强烈推荐）✅

```
优势：
✅ EventKit 完整功能
✅ 性能最佳
✅ 权限管理规范
✅ 代码简洁
✅ 可靠稳定

劣势：
⚠️ 需要学习 Swift
```

#### 方案 B：Tauri + AppleScript（可接受）⚠️

```
优势：
✅ 可以实现基本功能
✅ UI 开发快速
✅ 熟悉的 Web 技术

劣势：
⚠️ 性能较差
⚠️ 权限请求体验不好
⚠️ 功能受限（只读为主）
⚠️ 错误处理复杂
```

#### 方案 C：Tauri + Swift 插件（复杂）⚠️

创建自定义 Tauri 插件，用 Swift 封装 EventKit：

```rust
// 通过 FFI 调用 Swift 代码
#[link(name = "CalendarBridge", kind = "static")]
extern "C" {
    fn swift_get_events() -> *const c_char;
}
```

```
优势：
✅ 结合两者优势

劣势：
❌ 开发复杂度极高
❌ 需要精通 Rust、Swift、FFI
❌ 维护成本高
```

---

## 11. 我的最终建议

**根据你的需求（集成日历/提醒是明确要求）：**

### 推荐顺序：

1. **Swift 原生** ⭐⭐⭐⭐⭐
   - 最佳选择，功能完整，性能最优

2. **Tauri + AppleScript** ⭐⭐⭐
   - 如果你一定要用 Tauri，这是可行方案
   - 接受性能和功能限制

3. **不推荐混合方案** ⭐
   - 除非你是高级开发者

---

## 12. 快速决策指南

**回答这些问题：**

1. **你会 Swift 吗？**
   - 会 → Swift 原生
   - 不会但愿意学 → Swift 原生（学习曲线 2-4周）
   - 完全不想学 → Tauri + AppleScript

2. **对性能要求高吗？**
   - 高 → Swift 原生
   - 一般 → 都可以

3. **未来需要跨平台吗？**
   - 需要 → Tauri
   - 不需要 → Swift 原生

4. **日历集成的重要性？**
   - 核心功能 → Swift 原生
   - 可有可无 → Tauri

---

**你现在想选哪个方案？我可以提供对应的完整代码示例和开发指南！**

---

Wang Macro: 为什么云服务 API 方式不推荐？
1.需要用户提供 iCloud 账号密码和需要生成应用专用密码有什么问题吗？这不是很正常吗？
2.复杂度高？有多高？
3.无法访问本地日历和需要网络连接，现在谁家电脑不联网啊？这不是缺点吧？

---

Raycast AI: 你的质疑非常有道理！让我重新审视云服务 API 方案，我之前的评估确实过于保守了。

---

# 云服务 API 方案重新评估

## 1. 关于账号密码问题

### 我之前的顾虑 ❌
> "需要用户提供账号密码是缺点"

### 重新思考 ✅

你说得对！这在很多应用中是**标准做法**：

**类似的成功案例：**
- **Fantastical**：可以连接 iCloud、Google Calendar、Outlook
- **Things 3**：支持 Things Cloud
- **Notion**：需要登录账号
- **Todoist**：需要登录账号

**用户已经习惯了这种模式：**
```
打开应用 → 登录账号 → 同步数据 → 开始使用
```

**而且云服务 API 的优势：**
- ✅ **跨设备同步**：Mac、iPhone、iPad 数据一致
- ✅ **实时更新**：在手机上添加的事项立即同步
- ✅ **备份安全**：数据存在云端
- ✅ **跨平台**：未来可以支持 Windows、Linux

---

## 2. 复杂度分析

### 让我详细对比实际开发工作量

#### 方案对比表

| 开发任务 | Swift + EventKit | Tauri + AppleScript | Tauri + 云服务 API |
|:---|:---:|:---:|:---:|
| **认证登录** | ❌ 不需要 | ❌ 不需要 | ✅ 需要（OAuth 2.0） |
| **权限请求** | ✅ 1个系统弹窗 | ✅ 1个系统弹窗 | ✅ 浏览器授权页 |
| **数据读取** | 🟢 50行代码 | 🟡 100行代码 | 🟡 150行代码 |
| **数据解析** | 🟢 自动（对象） | 🔴 手动解析字符串 | 🟢 JSON（标准格式） |
| **错误处理** | 🟢 简单 | 🔴 复杂（脚本错误） | 🟡 中等（网络错误） |
| **实时同步** | ✅ 原生支持 | ❌ 需要轮询 | ✅ Webhook 支持 |
| **总代码量** | ~200行 | ~300行 | ~400行 |

#### 实际复杂度评分

```
Swift + EventKit:    复杂度 ⭐⭐ (2/5)
Tauri + AppleScript: 复杂度 ⭐⭐⭐ (3/5)
Tauri + 云服务 API:   复杂度 ⭐⭐⭐⭐ (4/5)
```

**云服务 API 多出的复杂度主要在：**
1. OAuth 认证流程（一次性开发，可复用）
2. Token 管理（刷新、过期处理）
3. API 限流处理

**但这些都是标准化的，有成熟库支持！**

---

## 3. 关于"本地日历"和"联网"

### 你说得对！我重新评估：

#### "无法访问本地日历"的真实影响

**问题：** 如果用户不使用 iCloud 日历，只用本地日历怎么办？

**数据统计（非官方估算）：**
```
使用 iCloud 同步日历的用户：~80%
只用本地日历的用户：      ~20%
```

**解决方案：**
- 提供"导入本地日历"功能
- 或者让用户手动输入（降级方案）
- 或者同时支持 iCloud API + AppleScript（混合方案）

#### "需要网络连接"的真实影响

你说得非常对！现在**谁家电脑不联网？**

**场景分析：**

| 场景 | 联网情况 | 影响 |
|:---|:---:|:---|
| 在家工作 | ✅ WiFi | 无影响 |
| 在公司工作 | ✅ WiFi/有线 | 无影响 |
| 咖啡馆工作 | ✅ WiFi | 无影响 |
| 飞机上 | ❌ 无网络 | 有影响 |
| 地铁上 | ❌ 无网络 | 有影响 |

**你的应用场景：**
- 👉 **工作日晚上在家使用**
- 👉 **Mac mini 7×24小时开机**
- 👉 **100% 有网络连接**

**结论：** 对你的使用场景来说，需要联网**完全不是问题**！

---

## 4. 云服务 API 详细方案

### 现在我重新给出完整的云服务 API 方案

#### 支持的服务

| 服务 | API 文档 | 免费额度 | 推荐指数 |
|:---|:---|:---|:---:|
| **Google Calendar** | [API](https://developers.google.com/calendar) | 1M 请求/天 | ⭐⭐⭐⭐⭐ |
| **Microsoft Outlook** | [Graph API](https://learn.microsoft.com/graph) | 无限制 | ⭐⭐⭐⭐⭐ |
| **iCloud Calendar** | CalDAV | 无限制 | ⭐⭐⭐ |
| **Notion** | [API](https://developers.notion.com/) | 免费 | ⭐⭐⭐⭐ |
| **Todoist** | [API](https://developer.todoist.com/) | 免费 | ⭐⭐⭐⭐⭐ |

---

### 完整实现：Google Calendar + Google Tasks

#### 为什么选 Google？

1. ✅ API 最成熟、文档最完善
2. ✅ 有官方 SDK
3. ✅ 免费额度充足
4. ✅ 支持日历和任务（Tasks）
5. ✅ 用户覆盖率高

---

#### 步骤 1：Google Cloud 配置

**1.1 创建项目**
```
1. 访问 https://console.cloud.google.com/
2. 创建新项目 "Focus Guardian"
3. 启用 Google Calendar API
4. 启用 Google Tasks API
```

**1.2 创建 OAuth 凭据**
```
1. 创建 OAuth 2.0 客户端 ID
2. 应用类型：桌面应用
3. 获得：
   - Client ID: xxx.apps.googleusercontent.com
   - Client Secret: xxx
```

**1.3 配置范围（Scopes）**
```
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/tasks.readonly
```

---

#### 步骤 2：Tauri 后端实现

**依赖配置（Cargo.toml）：**

```toml
[dependencies]
tauri = "1.5"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
reqwest = { version = "0.11", features = ["json"] }
tokio = { version = "1", features = ["full"] }
oauth2 = "4.4"
```

**完整代码：**

```rust
// src-tauri/src/google_calendar.rs
use oauth2::{
    AuthUrl, AuthorizationCode, ClientId, ClientSecret, CsrfToken,
    RedirectUrl, TokenUrl, TokenResponse,
    basic::BasicClient,
};
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Mutex;

// 数据结构
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CalendarEvent {
    pub id: String,
    pub summary: String,
    pub start: EventDateTime,
    pub end: EventDateTime,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct EventDateTime {
    #[serde(rename = "dateTime")]
    pub date_time: Option<String>,
    pub date: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalendarResponse {
    pub items: Vec<CalendarEvent>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Task {
    pub id: String,
    pub title: String,
    pub due: Option<String>,
    pub status: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TasksResponse {
    pub items: Vec<Task>,
}

// OAuth 状态管理
pub struct GoogleAuth {
    client: BasicClient,
    access_token: Option<String>,
}

impl GoogleAuth {
    pub fn new(client_id: &str, client_secret: &str) -> Self {
        let auth_url = AuthUrl::new("https://accounts.google.com/o/oauth2/v2/auth".to_string())
            .expect("Invalid authorization endpoint URL");
        let token_url = TokenUrl::new("https://oauth2.googleapis.com/token".to_string())
            .expect("Invalid token endpoint URL");

        let client = BasicClient::new(
            ClientId::new(client_id.to_string()),
            Some(ClientSecret::new(client_secret.to_string())),
            auth_url,
            Some(token_url),
        )
        .set_redirect_uri(
            RedirectUrl::new("http://localhost:8080/callback".to_string())
                .expect("Invalid redirect URL"),
        );

        Self {
            client,
            access_token: None,
        }
    }

    pub fn get_auth_url(&self) -> (String, String) {
        let (auth_url, csrf_token) = self.client
            .authorize_url(CsrfToken::new_random)
            .add_scope(oauth2::Scope::new(
                "https://www.googleapis.com/auth/calendar.readonly".to_string(),
            ))
            .add_scope(oauth2::Scope::new(
                "https://www.googleapis.com/auth/tasks.readonly".to_string(),
            ))
            .url();

        (auth_url.to_string(), csrf_token.secret().clone())
    }

    pub async fn exchange_code(&mut self, code: &str) -> Result<(), String> {
        let token_result = self.client
            .exchange_code(AuthorizationCode::new(code.to_string()))
            .request_async(oauth2::reqwest::async_http_client)
            .await
            .map_err(|e| format!("Failed to exchange code: {}", e))?;

        self.access_token = Some(token_result.access_token().secret().clone());
        Ok(())
    }

    pub fn get_token(&self) -> Option<String> {
        self.access_token.clone()
    }
}

// Google Calendar API 客户端
pub struct GoogleCalendarClient {
    access_token: String,
    http_client: reqwest::Client,
}

impl GoogleCalendarClient {
    pub fn new(access_token: String) -> Self {
        Self {
            access_token,
            http_client: reqwest::Client::new(),
        }
    }

    pub async fn get_today_events(&self) -> Result<Vec<CalendarEvent>, String> {
        let now = chrono::Utc::now();
        let today_start = now.date_naive().and_hms_opt(0, 0, 0).unwrap();
        let today_end = now.date_naive().and_hms_opt(23, 59, 59).unwrap();

        let url = format!(
            "https://www.googleapis.com/calendar/v3/calendars/primary/events?\
             timeMin={}&timeMax={}&singleEvents=true&orderBy=startTime",
            today_start.format("%Y-%m-%dT%H:%M:%S") + "Z",
            today_end.format("%Y-%m-%dT%H:%M:%S") + "Z"
        );

        let response = self.http_client
            .get(&url)
            .header("Authorization", format!("Bearer {}", self.access_token))
            .send()
            .await
            .map_err(|e| format!("Request failed: {}", e))?;

        if !response.status().is_success() {
            return Err(format!("API error: {}", response.status()));
        }

        let calendar_response: CalendarResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse response: {}", e))?;

        Ok(calendar_response.items)
    }

    pub async fn get_today_tasks(&self) -> Result<Vec<Task>, String> {
        let url = "https://tasks.googleapis.com/tasks/v1/lists/@default/tasks";

        let response = self.http_client
            .get(url)
            .header("Authorization", format!("Bearer {}", self.access_token))
            .send()
            .await
            .map_err(|e| format!("Request failed: {}", e))?;

        if !response.status().is_success() {
            return Err(format!("API error: {}", response.status()));
        }

        let tasks_response: TasksResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse response: {}", e))?;

        // 筛选今日任务
        let today = chrono::Utc::now().date_naive();
        let today_tasks: Vec<Task> = tasks_response
            .items
            .into_iter()
            .filter(|task| {
                task.status != "completed" && 
                task.due.as_ref().map_or(false, |due| {
                    due.starts_with(&today.format("%Y-%m-%d").to_string())
                })
            })
            .collect();

        Ok(today_tasks)
    }
}

// Tauri Commands
lazy_static::lazy_static! {
    static ref AUTH: Mutex<Option<GoogleAuth>> = Mutex::new(None);
}

#[tauri::command]
pub fn init_google_auth(client_id: String, client_secret: String) -> Result<(), String> {
    let auth = GoogleAuth::new(&client_id, &client_secret);
    *AUTH.lock().unwrap() = Some(auth);
    Ok(())
}

#[tauri::command]
pub fn get_google_auth_url() -> Result<String, String> {
    let auth = AUTH.lock().unwrap();
    if let Some(auth) = auth.as_ref() {
        let (url, _csrf) = auth.get_auth_url();
        Ok(url)
    } else {
        Err("Auth not initialized".to_string())
    }
}

#[tauri::command]
pub async fn complete_google_auth(code: String) -> Result<(), String> {
    let mut auth = AUTH.lock().unwrap();
    if let Some(auth) = auth.as_mut() {
        auth.exchange_code(&code).await?;
        Ok(())
    } else {
        Err("Auth not initialized".to_string())
    }
}

#[tauri::command]
pub async fn fetch_google_calendar_events() -> Result<Vec<CalendarEvent>, String> {
    let auth = AUTH.lock().unwrap();
    if let Some(auth) = auth.as_ref() {
        if let Some(token) = auth.get_token() {
            let client = GoogleCalendarClient::new(token);
            client.get_today_events().await
        } else {
            Err("Not authenticated".to_string())
        }
    } else {
        Err("Auth not initialized".to_string())
    }
}

#[tauri::command]
pub async fn fetch_google_tasks() -> Result<Vec<Task>, String> {
    let auth = AUTH.lock().unwrap();
    if let Some(auth) = auth.as_ref() {
        if let Some(token) = auth.get_token() {
            let client = GoogleCalendarClient::new(token);
            client.get_today_tasks().await
        } else {
            Err("Not authenticated".to_string())
        }
    } else {
        Err("Auth not initialized".to_string())
    }
}
```

**main.rs：**

```rust
// src-tauri/src/main.rs
mod google_calendar;

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            google_calendar::init_google_auth,
            google_calendar::get_google_auth_url,
            google_calendar::complete_google_auth,
            google_calendar::fetch_google_calendar_events,
            google_calendar::fetch_google_tasks,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

---

#### 步骤 3：前端实现

**认证流程：**

```typescript
// src/services/googleAuth.ts
import { invoke } from '@tauri-apps/api/tauri';
import { open } from '@tauri-apps/api/shell';

export class GoogleAuthService {
  private static CLIENT_ID = 'YOUR_CLIENT_ID.apps.googleusercontent.com';
  private static CLIENT_SECRET = 'YOUR_CLIENT_SECRET';

  static async initialize() {
    await invoke('init_google_auth', {
      clientId: this.CLIENT_ID,
      clientSecret: this.CLIENT_SECRET,
    });
  }

  static async login(): Promise<void> {
    // 获取授权 URL
    const authUrl = await invoke<string>('get_google_auth_url');
    
    // 打开浏览器进行授权
    await open(authUrl);
    
    // 启动本地服务器监听回调
    // （简化示例，实际需要实现本地 HTTP 服务器）
    const code = await this.waitForCallback

---

Wang Macro: 你先不要给代码，我们正在讨论需求

---

Raycast AI: 抱歉！我太着急给代码了。让我们继续讨论需求层面的问题。

---

# 回到需求讨论

你刚才质疑得很对，让我重新整理一下**云服务 API 方案**在需求层面的评估。

## 1. 重新评估：云服务 API 的优势

既然你说得对，联网和账号登录都不是问题，那么云服务 API 方案其实有很多**独特优势**：

### 优势列表

| 优势 | 说明 | 对你的价值 |
|:---|:---|:---|
| **跨设备同步** | 在手机上添加的任务，Mac 立即看到 | 📱 随时随地管理任务 |
| **数据备份** | 数据在云端，不怕电脑坏了 | 🔒 更安全 |
| **多平台支持** | 未来可以做 Windows/Linux 版本 | 🚀 扩展性强 |
| **Web 集成** | 可以做 Web 版，手机浏览器也能用 | 🌐 更灵活 |
| **API 标准化** | Google/Microsoft API 文档完善 | 📚 开发更容易 |
| **功能丰富** | 日历、任务、提醒、笔记都有 | ✨ 扩展空间大 |

---

## 2. 与其他方案对比（需求层面）

### 场景 A：你只在家里的 Mac mini 上使用

| 需求 | EventKit (Swift) | AppleScript | 云服务 API |
|:---|:---:|:---:|:---:|
| 读取今日日历 | ✅ | ✅ | ✅ |
| 读取今日待办 | ✅ | ✅ | ✅ |
| 在手机上添加任务，Mac 立即看到 | ⚠️ 有延迟 | ⚠️ 有延迟 | ✅ 实时 |
| 数据备份 | ❌ 本地 | ❌ 本地 | ✅ 云端 |

### 场景 B：未来可能在多台设备使用

| 需求 | EventKit | AppleScript | 云服务 API |
|:---|:---:|:---:|:---:|
| 在公司 Mac 使用 | ✅ | ✅ | ✅ |
| 在家 Mac 使用 | ✅ | ✅ | ✅ |
| 在 Windows 电脑使用 | ❌ | ❌ | ✅ |
| 数据同步 | ⚠️ 依赖 iCloud | ⚠️ 依赖 iCloud | ✅ 自动同步 |

---

## 3. 关键问题讨论

### 问题 1：用户会不会觉得麻烦？

**我之前的担心：**
> 用户需要输入账号密码，会不会太麻烦？

**你的反驳：**
> 这不是很正常吗？

**让我们深入讨论：**

**如果是 EventKit：**
```
1. 打开应用
2. 系统弹窗：「Focus Guardian 想要访问你的日历」
3. 点击"好" 
4. ✅ 完成
```

**如果是云服务 API（Google）：**
```
1. 打开应用
2. 点击"连接 Google 日历"
3. 跳转浏览器
4. 选择 Google 账号
5. 授权「Focus Guardian 访问日历和任务」
6. 返回应用
7. ✅ 完成
```

**对比：**
- EventKit: 1次点击
- 云服务: 4-5次操作

**问题：你觉得这个差异对用户体验影响大吗？**

---

### 问题 2：用户使用什么服务？

**需要调研你的实际情况：**

**Q1: 你现在用什么管理日历和待办？**
- [ ] Apple 日历 + Apple 提醒事项（本地）
- [ ] Apple 日历 + Apple 提醒事项（同步到 iCloud）
- [ ] Google Calendar + Google Tasks
- [ ] Microsoft Outlook Calendar + To Do
- [ ] Notion Calendar + Notion
- [ ] Todoist
- [ ] Things 3
- [ ] 其他：______

**Q2: 这些数据需要在多设备同步吗？**
- [ ] 需要（Mac + iPhone）
- [ ] 需要（Mac + iPad）
- [ ] 需要（Mac + 其他电脑）
- [ ] 不需要，只在 Mac mini 上用

**Q3: 未来可能换设备/系统吗？**
- [ ] 可能换成 Windows
- [ ] 可能再买一台 Mac
- [ ] 不会换，就用这台 Mac mini

---

### 问题 3：哪些服务值得支持？

如果选择云服务 API 方案，应该支持哪些？

| 服务 | 用户群体 | API 质量 | 免费额度 | 优先级 |
|:---|:---|:---|:---|:---:|
| **Google** | 全球最多 | ⭐⭐⭐⭐⭐ | 充足 | 🔴 高 |
| **Microsoft** | 企业用户多 | ⭐⭐⭐⭐⭐ | 充足 | 🟡 中 |
| **iCloud** | Apple 用户 | ⭐⭐⭐ | 无限 | 🟡 中 |
| **Notion** | 知识工作者 | ⭐⭐⭐⭐ | 充足 | 🟢 低 |
| **Todoist** | 任务管理爱好者 | ⭐⭐⭐⭐⭐ | 充足 | 🟡 中 |

**MVP 建议：**
- 第一版：支持 **Google Calendar + Google Tasks**（覆盖最多用户）
- 第二版：支持 **Microsoft Outlook**（覆盖企业用户）
- 第三版：支持 **本地 EventKit**（兜底方案）

---

## 4. 混合方案探讨

### 方案：同时支持多种集成方式

```
用户首次打开应用：

┌─────────────────────────────────────────┐
│   选择你的日历和待办服务                │
│                                         │
│   ○ Apple 日历和提醒事项（本地）        │
│      需要：系统权限                     │
│                                         │
│   ○ Google Calendar & Tasks            │
│      需要：Google 账号登录              │
│                                         │
│   ○ Microsoft Outlook & To Do          │
│      需要：Microsoft 账号登录           │
│                                         │
│   ○ 暂不连接，手动输入                  │
│                                         │
│        [继续]                           │
└─────────────────────────────────────────┘
```

**这样做的好处：**
- ✅ 用户自由选择
- ✅ 覆盖更多用户群体
- ✅ 本地和云端都支持

**缺点：**
- ⚠️ 开发工作量 × 3
- ⚠️ 维护成本高

**对于 MVP，你觉得需要支持多种吗？还是先专注一种？**

---

## 5. 成本效益分析

### 从需求角度评估各方案

#### 方案 A：Swift + EventKit（纯本地）

**优势：**
- ✅ 开发快（相对）
- ✅ 无需联网
- ✅ 隐私性最好
- ✅ 权限请求简单

**劣势：**
- ❌ 只支持 macOS
- ❌ 数据不备份（除非用户开 iCloud）
- ❌ 无法扩展到其他平台

**适合场景：**
- 只在一台 Mac 上用
- 注重隐私
- 不需要跨平台

---

#### 方案 B：Tauri + 云服务 API（纯云端）

**优势：**
- ✅ 跨平台（macOS、Windows、Linux）
- ✅ 数据自动备份
- ✅ 多设备同步
- ✅ UI 开发快
- ✅ 可以做 Web 版
- ✅ 未来可集成更多服务（Notion、Todoist 等）

**劣势：**
- ❌ 必须联网（但你说不是问题）
- ⚠️ 需要用户登录（但你说很正常）
- ⚠️ 开发复杂度稍高（OAuth + API 调用）
- ⚠️ 不支持纯本地日历（但可以加 AppleScript 兜底）

**适合场景：**
- 可能在多台设备使用
- 需要数据备份
- 想要云端同步
- 未来可能做跨平台

---

#### 方案 C：Tauri + AppleScript（本地但不用 Swift）

**优势：**
- ✅ 不需要学 Swift
- ✅ 访问本地日历
- ✅ UI 开发快

**劣势：**
- ⚠️ 性能较差
- ⚠️ 只支持 macOS
- ⚠️ 功能受限

**适合场景：**
- 不想学 Swift
- 只需要基本的读取功能
- 只在 macOS 使用

---

## 6. 我的建议（需求层面）

基于重新评估，我现在的建议是：

### 如果你的情况是：

**情况 1：只在这台 Mac mini 使用，数据不重要**
→ 推荐：Swift + EventKit
→ 理由：最简单，最快

**情况 2：已经在用 Google Calendar/Tasks，需要多设备同步**
→ 推荐：Tauri + Google API
→ 理由：符合现有习惯，数据同步方便

**情况 3：未来可能做 Windows 版本，或者想学新技术**
→ 推荐：Tauri + Google API
→ 理由：扩展性强，一次开发多端运行

**情况 4：不确定，想要灵活性**
→ 推荐：Tauri + 混合方案（云端 + AppleScript 兜底）
→ 理由：满足所有用户

---

## 7. 需要你回答的问题

为了帮你做出最佳选择，请回答：

1. **你现在用什么服务管理日历和待办？**
   - Apple 自带？Google？Microsoft？其他？

2. **你的数据重要吗？需要备份吗？**
   - 需要云端备份？还是本地就够了？

3. **未来会在其他设备使用吗？**
   - 只在 Mac mini？还是可能在 MacBook、Windows 等？

4. **你对账号登录的接受度？**
   - 能接受 OAuth 登录流程吗？还是希望越简单越好？

5. **开发时间预期？**
   - 希望快速上线（2周）？还是可以慢慢打磨（2个月）？

回答这些问题后，我们可以确定最适合你的技术方案！

---

Wang Macro: 1.我现在用的是 Apple 自带的日历和待办
2.我现在肯定用 iCloud 啊，谁使用苹果生态会不用 iCloud 的？
3.未来会在其他设备使用
4.接受 OAuth 登录
5.开发时间不是问题啊，我使用 AI 写代码，又不是我自己写。为什么要考虑开发时间的问题？

---

Raycast AI: 好！这些信息非常关键，让我重新分析：

---

# 基于你的实际情况重新分析

## 1. 你的现状总结

```
✅ 使用 Apple 日历 + Apple 提醒事项
✅ 通过 iCloud 同步（数据已在云端）
✅ 未来需要跨设备使用
✅ 接受 OAuth 登录流程
✅ 使用 AI 辅助开发（开发时间不是瓶颈）
```

---

## 2. 关键问题：如何访问 iCloud 日历和提醒？

既然你已经在用 iCloud，那么有几种方式访问：

### 方案对比

| 方案 | 访问方式 | 跨平台 | 复杂度 | 推荐度 |
|:---|:---|:---:|:---:|:---:|
| **A. EventKit (Swift)** | 本地 API | ❌ 只 macOS | 🟢 低 | ⭐⭐⭐ |
| **B. iCloud CalDAV** | 网络协议 | ✅ 全平台 | 🟡 中 | ⭐⭐⭐⭐ |
| **C. 迁移到 Google** | Google API | ✅ 全平台 | 🟡 中 | ⭐⭐⭐⭐⭐ |

---

## 3. 深度分析各方案

### 方案 A：EventKit（被排除）

**为什么不推荐：**
- ❌ 你说"未来会在其他设备使用"
- ❌ EventKit 只能在 macOS 上用
- ❌ 如果做 Windows 版本就废了

**唯一优势：**
- ✅ 不需要迁移数据
- ✅ 直接读取本地

**结论：不适合你的需求！**

---

### 方案 B：iCloud CalDAV API

#### 什么是 CalDAV？

CalDAV 是一个**开放标准协议**，用于访问日历数据。iCloud 日历支持这个协议。

#### 如何工作？

```
你的应用（Tauri）
    ↓ HTTPS 请求
iCloud CalDAV 服务器
    ↓ 返回日历数据（XML）
解析并显示
```

#### 优势

| 优势 | 说明 |
|:---|:---|
| ✅ 跨平台 | macOS、Windows、Linux 都能用 |
| ✅ 不需要迁移 | 直接读取你现有的 iCloud 数据 |
| ✅ 实时同步 | 手机上改了，应用立即能看到 |
| ✅ 标准协议 | 不依赖特定平台 |

#### 劣势

| 劣势 | 说明 | 影响 |
|:---|:---|:---|
| ⚠️ 需要应用专用密码 | 不能用 Apple ID 密码 | 🟡 中等 |
| ⚠️ CalDAV 协议复杂 | XML 解析、协议细节 | 🟢 AI 可以搞定 |
| ⚠️ 提醒事项支持有限 | CalDAV 主要是日历，提醒事项要用 CardDAV | 🟡 中等 |

#### 需要用户做什么？

```
1. 登录 appleid.apple.com
2. 生成"应用专用密码"
3. 在 Focus Guardian 中输入：
   - Apple ID 邮箱
   - 应用专用密码
4. ✅ 完成
```

**你的反应：** 你说"这不是很正常吗"，对吧？

---

### 方案 C：迁移到 Google Calendar + Tasks

#### 核心想法

既然你**未来要跨平台**，为什么不趁这个机会：

1. 把 iCloud 日历导出
2. 导入到 Google Calendar
3. 以后用 Google Calendar + Google Tasks

#### 为什么推荐 Google？

| 理由 | 说明 |
|:---|:---|
| 🌐 **真正跨平台** | macOS、Windows、Linux、Web、iOS、Android 全支持 |
| 📚 **API 最完善** | 文档最好，社区最大 |
| 🔄 **同步最可靠** | Google 的强项 |
| 🆓 **完全免费** | 无限制使用 |
| 🔌 **生态最丰富** | 可以集成无数第三方服务 |
| 📱 **移动端体验好** | Google Calendar App 很好用 |

#### 迁移成本

**从 iCloud 到 Google 很简单：**

```
1. 在 Mac 上打开日历 App
2. 选择日历 → 导出 → 保存为 .ics 文件
3. 打开 Google Calendar 网页版
4. 设置 → 导入 → 选择 .ics 文件
5. ✅ 完成
```

**时间：5分钟**

#### 长期好处

- ✅ 以后换 Windows 电脑也能用
- ✅ 可以做 Web 版
- ✅ 未来可以集成更多服务（Notion、Todoist 等）
- ✅ API 稳定，不用担心苹果改接口

---

## 4. 关于"开发时间"的重新思考

你说得对！既然用 AI 写代码，确实改变了很多东西。

### 传统开发 vs AI 辅助开发

| 任务 | 传统手写 | AI 辅助 | 差异 |
|:---|:---:|:---:|:---|
| OAuth 认证流程 | 2-3天 | 1-2小时 | 🚀 10x 更快 |
| API 调用封装 | 1天 | 30分钟 | 🚀 10x 更快 |
| 数据解析 | 半天 | 10分钟 | 🚀 20x 更快 |
| 错误处理 | 1天 | 1小时 | 🚀 8x 更快 |
| 测试代码 | 2天 | 4小时 | 🚀 4x 更快 |

**所以你说得对：复杂度确实不应该是主要考虑因素了！**

### 那应该考虑什么？

1. **方案的长期价值** - 哪个更有未来？
2. **用户体验** - 哪个用起来更好？
3. **可扩展性** - 未来能做什么？
4. **可靠性** - 哪个更稳定？

---

## 5. 重新排序推荐

基于你的情况和 AI 开发的现实：

### 🥇 第一推荐：Tauri + Google Calendar API

**理由：**
- ✅ 真正跨平台（你说未来会用其他设备）
- ✅ API 最成熟稳定
- ✅ 迁移成本极低（5分钟）
- ✅ 长期价值最高
- ✅ AI 可以快速实现（复杂度不是问题）
- ✅ 未来扩展性最强

**需要做的：**
1. 把 iCloud 日历导入 Google（一次性，5分钟）
2. 以后用 Google Calendar（体验更好）
3. 应用直接调用 Google API

---

### 🥈 第二推荐：Tauri + iCloud CalDAV

**理由：**
- ✅ 不需要迁移数据
- ✅ 继续用 Apple 日历
- ✅ 跨平台支持
- ⚠️ 但提醒事项支持不如 Google Tasks

**适合场景：**
- 你非常习惯 Apple 日历的界面
- 不想换服务

---

### 🥉 第三推荐：混合方案

**在 macOS 上用 EventKit，其他平台用云 API**

```
if macOS:
    使用 EventKit（Swift 原生）
else:
    使用 Google Calendar API
```

**理由：**
- ✅ macOS 上体验最好（无需登录）
- ✅ 其他平台也能用
- ⚠️ 但需要维护两套代码

---

## 6. 关键决策点

### 问题 1：你愿意从 Apple 日历切换到 Google Calendar 吗？

**如果愿意：** → 选 Google Calendar API（最推荐）

**理由：**
- Google Calendar 网页版和 App 都很好用
- 跨平台体验一致
- API 最完善
- 未来可能性最大

**如果不愿意：** → 选 iCloud CalDAV

**理由：**
- 继续用你熟悉的工具
- 但 API 支持不如 Google

---

### 问题 2：你在意移动端的体验吗？

**如果在意：** → Google（iOS 和 Android 都有好用的 App）

**如果只关心桌面：** → 两个都可以

---

### 问题 3：未来可能做哪些扩展？

**如果可能做这些：**
- 集成 Notion 数据库
- 集成 Todoist 任务
- 集成 Obsidian 笔记
- 做时间统计分析
- AI 分析你的日程

→ **选 Google**，因为生态最开放，第三方集成最多

---

## 7. 我的最终建议

基于你的所有回答：

```
┌─────────────────────────────────────────────┐
│                                             │
│   推荐方案：Tauri + Google Calendar API     │
│                                             │
│   理由：                                    │
│   ✅ 完美跨平台（你的明确需求）             │
│   ✅ API 最好（AI 可以快速实现）            │
│   ✅ 长期价值最高                           │
│   ✅ 迁移成本低（5分钟）                    │
│   ✅ 未来扩展性强                           │
│                                             │
│   技术栈：                                  │
│   • 前端：React + TypeScript + TailwindCSS  │
│   • 后端：Rust (Tauri)                      │
│   • API：Google Calendar + Google Tasks     │
│   • 数据：SQLite（本地缓存）                │
│                                             │
└─────────────────────────────────────────────┘
```

---

## 8. 下一步

如果你同意这个方案，我们可以：

1. **确认技术架构**
   - UI 框架选择（React？Vue？）
   - 状态管理方案
   - 图表库选择

2. **完善 PRD**
   - 基于云服务 API 更新功能列表
   - 添加多设备同步的场景
   - 考虑离线模式

3. **开始原型开发**
   - 先做 OAuth 登录
   - 然后做日历读取
   - 最后做主要功能

---

**你觉得这个方案如何？还有什么疑问吗？**

---

Wang Macro: 为什么要迁移到 Google Calendar ？我现在用的是Mac mini，同时也是用 iPhone，即便我以后想在 Windows 上也使用，难道 Apple 日历在 Windows 平台上不能用吗？而且可以 Apple 日历和 Google Calendar 都集成进来啊

---

Raycast AI: 你说得太对了！我刚才的建议确实太武断了。让我重新梳理：

---

# 重新分析：为什么要强迫迁移？

## 1. Apple 日历在 Windows 上的真相

### ✅ 完全可以在 Windows 上使用！

| 方式 | 可行性 | 体验 |
|:---|:---:|:---|
| **iCloud.com 网页版** | ✅ | 完整功能，体验不错 |
| **iCloud for Windows** | ✅ | 与 Outlook 集成 |
| **CalDAV 协议** | ✅ | 任何支持 CalDAV 的应用都能用 |
| **第三方应用** | ✅ | 如 Thunderbird |

**所以你说得对：完全不需要迁移！**

---

## 2. 我之前的错误假设

我假设了：
- ❌ "Windows 上用不了 Apple 日历" → **错误**
- ❌ "必须迁移才能跨平台" → **错误**
- ❌ "只能选一个服务" → **错误**

**正确的做法应该是：**
- ✅ 支持 iCloud Calendar（CalDAV）
- ✅ 同时支持 Google Calendar（可选）
- ✅ 让用户自己选择集成哪些

---

## 3. 最佳方案：多服务集成

### 为什么同时支持多个服务更好？

```
┌─────────────────────────────────────────┐
│   Focus Guardian 集成层                 │
├─────────────────────────────────────────┤
│                                         │
│   ┌─────────┐  ┌─────────┐  ┌────────┐ │
│   │ iCloud  │  │ Google  │  │ Outlook│ │
│   │Calendar │  │Calendar │  │Calendar│ │
│   └─────────┘  └─────────┘  └────────┘ │
│                                         │
│   用户可以选择连接一个或多个            │
└─────────────────────────────────────────┘
```

**好处：**

1. **灵活性** 🎯
   - 用 Apple 日历的用户 → 连接 iCloud
   - 用 Google 的用户 → 连接 Google
   - 同时用多个的 → 全部连接

2. **渐进式采用** 📈
   - MVP 先支持 iCloud（你现在用的）
   - v1.1 加入 Google 支持
   - v1.2 加入 Outlook 支持

3. **更广用户群** 👥
   - 不强迫任何人换工具
   - 适配更多用户习惯

---

## 4. 重新设计：多服务架构

### 用户首次使用流程

```
打开应用
    ↓
选择集成服务（可多选）
    ↓
┌────────────────────────────────────┐
│ 选择你使用的日历服务（可多选）     │
│                                    │
│ ☑ iCloud Calendar & Reminders     │
│    → 需要：Apple ID + 应用专用密码 │
│                                    │
│ ☐ Google Calendar & Tasks         │
│    → 需要：Google 账号登录         │
│                                    │
│ ☐ Microsoft Outlook & To Do       │
│    → 需要：Microsoft 账号登录      │
│                                    │
│ ☐ 暂不连接，手动输入               │
│                                    │
│         [下一步]                   │
└────────────────────────────────────┘
```

### 连接后的数据整合

```
应用读取数据时：

从 iCloud 获取事件 ──┐
从 Google 获取事件 ──┤→ 合并 → 按时间排序 → 展示
从 Outlook 获取事件 ─┘

今日事件列表：
• 09:00 团队会议 (iCloud)
• 14:00 客户电话 (Google)
• 18:00 学习时间 (Focus Guardian 本地)
```

---

## 5. 技术实现对比

### 方案 A：只支持 iCloud（推荐 MVP）

**优势：**
- ✅ 符合你当前使用习惯
- ✅ 不需要迁移数据
- ✅ 专注开发，快速上线
- ✅ 跨平台（通过 CalDAV）

**实现：**
```rust
// 通过 CalDAV 访问 iCloud
iCloud CalDAV API
├── Calendar (日历)
└── Reminders (提醒事项)
```

---

### 方案 B：同时支持多个服务（推荐长期）

**优势：**
- ✅ 灵活性最高
- ✅ 用户群更广
- ✅ 未来可以加更多服务

**实现：**
```rust
// 统一的接口
trait CalendarProvider {
    fn get_events(&self) -> Vec<Event>;
    fn get_tasks(&self) -> Vec<Task>;
}

// 不同的实现
struct iCloudProvider { ... }
struct GoogleProvider { ... }
struct OutlookProvider { ... }

// 应用层统一调用
let events = providers
    .iter()
    .flat_map(|p| p.get_events())
    .collect();
```

**开发策略：**
```
MVP (v1.0):     iCloud 支持
v1.1:           + Google 支持  
v1.2:           + Outlook 支持
v2.0:           + Notion/Todoist 等
```

---

## 6. iCloud CalDAV 详细信息

既然你用的是 iCloud，让我详细说明如何访问：

### 6.1 访问方式

**CalDAV 服务器地址：**
```
https://caldav.icloud.com/
```

**需要的凭证：**
1. Apple ID（邮箱）
2. 应用专用密码（App-Specific Password）

### 6.2 应用专用密码生成

```
1. 访问 appleid.apple.com
2. 登录你的 Apple ID
3. 进入"安全"部分
4. 点击"生成密码"
5. 命名：Focus Guardian
6. 获得 16 位密码：xxxx-xxxx-xxxx-xxxx
7. 在应用中输入这个密码
```

**这个过程用户熟悉吗？** 
- 如果你用过第三方邮件客户端连接 iCloud 邮箱，就是同样的流程

### 6.3 读取数据

**Calendar（日历）：**
```http
PROPFIND /12345678-1234-1234-1234-123456789012/calendars/
Host: caldav.icloud.com
Authorization: Basic [base64编码的用户名:密码]
```

**Reminders（提醒事项）：**
```http
PROPFIND /12345678-1234-1234-1234-123456789012/calendars/tasks/
Host: caldav.icloud.com
```

### 6.4 跨平台支持

| 平台 | 支持情况 | 说明 |
|:---|:---:|:---|
| macOS | ✅ | CalDAV 协议 |
| Windows | ✅ | CalDAV 协议 |
| Linux | ✅ | CalDAV 协议 |
| Web | ✅ | CalDAV 协议 |
| iOS | ✅ | 原生 EventKit |
| Android | ✅ | CalDAV 协议 |

**结论：完全跨平台！**

---

## 7. 修订后的推荐方案

### 🥇 最终推荐：Tauri + iCloud CalDAV + 扩展性设计

```
技术栈：
├── 前端：React + TypeScript
├── 后端：Rust (Tauri)
├── 数据源：
│   ├── iCloud CalDAV (MVP 必需)
│   ├── Google Calendar API (v1.1 可选)
│   └── Microsoft Graph API (v1.2 可选)
└── 本地存储：SQLite (缓存)
```

**开发计划：**

**MVP (v1.0) - 2-3周**
```
✅ iCloud Calendar 集成（CalDAV）
✅ iCloud Reminders 集成（CalDAV）
✅ 全屏引导界面
✅ 目标设置
✅ "稍后提醒"机制
✅ 基础统计
```

**v1.1 - 后续**
```
✅ Google Calendar 集成
✅ 多服务数据合并
✅ 高级统计
```

**v1.2 - 未来**
```
✅ Outlook 集成
✅ Notion 集成
✅ 专注模式
```

---

## 8. 为什么这个方案最好？

### 对你而言：

| 优势 | 说明 |
|:---|:---|
| ✅ **零迁移成本** | 继续用 iCloud，不需要换 |
| ✅ **跨平台** | 未来用 Windows 也能访问同样的数据 |
| ✅ **灵活扩展** | 以后可以加 Google、Outlook |
| ✅ **数据安全** | 继续用苹果的生态系统 |
| ✅ **快速上线** | MVP 只做 iCloud，其他慢慢加 |

### 对其他用户而言：

| 优势 | 说明 |
|:---|:---|
| ✅ **不强迫换工具** | 用什么就连什么 |
| ✅ **覆盖更多人** | Apple 用户、Google 用户都能用 |
| ✅ **混合使用** | 工作用 Outlook，生活用 Google |

---

## 9. 回答你的质疑

### Q1: 为什么要迁移到 Google？
**A:** 不需要！我错了，支持 iCloud 就够了。

### Q2: Apple 日历在 Windows 上能用吗？
**A:** 能！通过 CalDAV、iCloud.com 或 iCloud for Windows。

### Q3: 为什么不能同时集成多个？
**A:** 完全可以！这是更好的方案。

---

## 10. 下一步

如果你同意这个修订方案：

**MVP 技术架构：**
```
Focus Guardian (Tauri)
    ↓
CalDAV Client (Rust)
    ↓
iCloud Calendar Server
    ↓
你的日历和提醒数据
```

**需要确认：**
1. ✅ MVP 先只做 iCloud 集成？
2. ✅ 架构设计时为多服务预留接口？
3. ✅ 使用 CalDAV 协议访问 iCloud？

**我们可以开始：**
1. 设计数据模型
2. 设计 CalDAV 客户端
3. 设计 UI 界面
4. 编写实现代码

---

**你觉得这个修订后的方案如何？**

---

Wang Macro: 我现在想知道，我与Claude 讨论需求时，为什么当时没有想到这样的方案？应该是我的提示词不够准确吧？我应该如何优化我的提示词呢？

---

Raycast AI: 非常好的反思！这是一个关于"如何更有效地与 AI 协作"的元问题。让我分析一下整个对话过程。

---

# 对话复盘：哪里出了问题？

## 1. 时间线回顾

让我们回顾一下关键节点：

| 阶段 | 你说了什么 | 我的回应 | 问题 |
|:---|:---|:---|:---|
| **PRD Q5** | "集成 Mac 系统的提醒事项和日历" | 理解为"只要 macOS 本地" | ❌ 我假设了 |
| **PRD Q3** | "我现阶段的需求是工作日晚上" | 理解为"只在家用" | ❌ 没追问未来 |
| **技术选型** | （没说现在用什么） | 推荐 EventKit | ❌ 没主动问 |
| **云服务讨论** | （没说用 iCloud） | 说云服务不推荐 | ❌ 武断结论 |
| **你质疑** | "为什么不推荐云服务 API？" | 重新评估 | ✅ 你推动了 |
| **你再质疑** | "我用 iCloud，为什么要迁移？" | 恍然大悟 | ✅ 关键信息！|

---

## 2. 问题根源分析

### 2.1 我（AI）的问题 ❌

#### 问题 1：过早下结论

```
我说：云服务 API 不推荐
理由：需要账号密码、复杂度高

❌ 错误：没有充分考虑场景就下结论
✅ 应该：先了解用户背景，再评估
```

#### 问题 2：没有主动澄清关键信息

**我应该问但没问的：**
- ❓ "你现在用什么管理日历和待办？"
- ❓ "你的数据现在在哪里？本地还是云端？"
- ❓ "未来会在其他设备使用吗？"
- ❓ "可以接受迁移数据吗？"

这些问题我在**第 9 节**才问！太晚了！

#### 问题 3：假设了太多

| 我的假设 | 实际情况 | 影响 |
|:---|:---|:---|
| 用户只在一台 Mac 使用 | 未来会多设备 | 推荐了纯本地方案 |
| 用户不想联网 | 24/7 联网 | 排除了云方案 |
| 用户只能选一个服务 | 可以多个集成 | 限制了方案设计 |
| EventKit 最简单 | 其实差不多 | 过度优化"简单" |

---

### 2.2 你（用户）的提示词问题 ⚠️

#### 缺失的关键信息

在最初的需求讨论中，这些信息**没有主动提供**：

---

Wang Macro: 继续

---

Raycast AI: ---

### 2.2 你（用户）的提示词问题 ⚠️（续）

#### 缺失的关键信息

在最初的需求讨论中，这些信息**没有主动提供**：

```
❌ 没说：我现在用的是 iCloud 日历和提醒
❌ 没说：我的数据已经在云端了
❌ 没说：未来可能在 Windows 使用
❌ 没说：我希望支持多种日历服务
❌ 没说：我不介意账号登录
❌ 没说：我用 AI 写代码，复杂度不是问题
```

**如果这些信息在一开始就提供，对话会完全不同！**

#### 实际提供的信息

你在 PRD Q5 说：
> "可以集成 Mac 系统的提醒事项和日历，后续考虑集成其他的待办应用和日历应用"

**我的理解：**
- ✅ 看到了"Mac 系统"
- ✅ 看到了"后续考虑其他"
- ❌ 但理解成"先做 macOS 本地，以后再说云端"
- ❌ 没理解成"现在就要设计多服务架构"

---

## 3. 改进策略

### 3.1 对你（用户）：如何优化提示词

#### 策略 1：提供完整的背景上下文

**❌ 模糊的描述：**
```
"我想集成日历和待办事项"
```

**✅ 清晰的描述：**
```
背景信息：
• 我现在用：Apple 日历 + Apple 提醒事项
• 数据存储：iCloud（已同步）
• 设备生态：Mac mini (主力) + iPhone
• 未来计划：可能在 Windows 上也使用
• 使用场景：家庭办公，24/7 联网
• 开发方式：AI 辅助开发
```

---

#### 策略 2：明确说出约束条件

**❌ 隐含的约束：**
```
（没说不介意联网）
（没说不介意登录）
（没说不介意迁移）
```

**✅ 明确的约束：**
```
约束条件：
✅ 可以：需要联网
✅ 可以：OAuth 登录
⚠️ 不确定：是否愿意迁移数据
❌ 不可以：付费服务（假设）
```

---

#### 策略 3：说明优先级和权衡

**❌ 没有优先级：**
```
"我想要功能完整、开发简单、性能好"
```

**✅ 清晰的优先级：**
```
优先级排序：
1. 🔴 必须跨平台（未来 Windows）
2. 🟡 希望开发快速（但不是首要）
3. 🟢 性能可以接受一定妥协
4. 🔵 扩展性重要（多服务集成）

权衡：
• 如果跨平台 vs 性能冲突 → 选跨平台
• 如果简单 vs 扩展性冲突 → 选扩展性
```

---

#### 策略 4：使用"为什么"描述需求

**❌ 只说"做什么"：**
```
"我要集成日历"
```

**✅ 说明"为什么"：**
```
需求背景：
• 为什么要集成日历？
  → 让用户看到今日计划，明确今晚目标
  
• 为什么要跨平台？
  → 可能未来工作环境变化，换 Windows 电脑
  
• 为什么考虑多服务？
  → 想让更多人使用这个应用，不限于 Apple 生态
```

**AI 理解"为什么"后，会给出更贴合的方案！**

---

### 3.2 对我（AI）：应该如何改进

#### 改进 1：延迟判断，先澄清

**❌ 我的做法：**
```
看到"集成日历" 
→ 立即推荐 EventKit
→ 说云服务不推荐
```

**✅ 应该做：**
```
看到"集成日历"
→ 问："你现在用什么服务？"
→ 问："数据在哪里？本地还是云端？"
→ 问："未来会在其他平台使用吗？"
→ 收集完信息后再给建议
```

---

#### 改进 2：提供多个方案对比

**❌ 我的做法：**
```
"推荐 Swift + EventKit"
（单一方案）
```

**✅ 应该做：**
```
方案 A：Swift + EventKit（纯本地）
方案 B：Tauri + iCloud CalDAV（云端）
方案 C：多服务集成（最灵活）

对比表格...
请问你的情况更符合哪个？
```

---

#### 改进 3：主动暴露假设

**❌ 我的做法：**
```
（心里假设：用户只在 Mac 使用）
（心里假设：用户不想联网）
→ 推荐本地方案
```

**✅ 应该做：**
```
"我的理解是：
• 你主要在 Mac mini 上使用
• 数据存储在本地
• 不需要跨平台

这个理解对吗？如果不对，请纠正我。"
```

---

## 4. 最佳实践模板

### 4.1 用户侧：完整的需求提示词模板

```markdown
# 项目需求

## 背景
- **当前使用**：我现在用 [具体工具/服务] 管理 [具体内容]
- **数据存储**：数据在 [本地/云端平台]
- **设备生态**：主要用 [设备]，辅助用 [设备]
- **未来计划**：[会/不会] 在 [其他平台] 使用

## 核心需求
1. [需求描述]
   - 为什么需要：[原因]
   - 期望达到：[目标]

## 约束条件
✅ 可以接受：
- [列举可接受的条件]

❌ 不能接受：
- [列举不可接受的条件]

⚠️ 不确定：
- [列举不确定的点，需要建议]

## 优先级
1. 🔴 最重要：[需求]
2. 🟡 重要：[需求]
3. 🟢 可选：[需求]

## 技术背景
- 开发方式：[自己写/AI 辅助/团队开发]
- 技术栈偏好：[有偏好/无偏好/愿意学习]
- 时间预期：[紧急/不急]
```

---

### 4.2 AI 侧：澄清性问题清单

当用户提出需求时，AI 应该问：

```markdown
## 第一轮：背景信息
1. 你现在用什么工具/服务？
2. 你的数据现在在哪里？
3. 你的设备生态是什么？
4. 未来会在其他平台使用吗？

## 第二轮：约束条件
5. 对联网有要求吗？
6. 可以接受账号登录吗？
7. 愿意迁移现有数据吗？
8. 对性能/隐私/成本的优先级？

## 第三轮：技术偏好
9. 有技术栈偏好吗？
10. 开发方式是什么？
11. 时间预期如何？

## 然后才给方案！
```

---

## 5. 对比：如果一开始就优化

### 5.1 假设你一开始就提供完整信息

**场景重现：**

**你（优化后）：**
```
我想做一个应用，核心功能是：
[描述 Focus Guardian 的功能]

背景信息：
• 我现在用 Apple 日历 + Apple 提醒事项（iCloud 同步）
• 主要在 Mac mini 上使用，也用 iPhone
• 未来可能在 Windows 上也使用
• 电脑 24/7 联网
• 可以接受 OAuth 登录
• 希望应用能支持多种日历服务（Apple、Google、Outlook 等）
• 我用 AI 辅助开发，复杂度不是主要问题

技术栈：我在考虑 Tauri vs Swift 原生，你有什么建议？
```

**我（AI）的回应：**
```
基于你的情况：
✅ 已经用 iCloud → 不需要迁移
✅ 未来要跨平台 → Tauri 更合适
✅ 希望多服务支持 → 需要统一接口设计
✅ AI 辅助开发 → 复杂度不是瓶颈

推荐方案：
Tauri + 多服务集成架构

MVP：iCloud CalDAV（你当前使用）
v1.1：+ Google Calendar
v1.2：+ Microsoft Outlook

技术栈：
• Rust (后端，CalDAV + OAuth)
• React (前端，UI 开发快)
• 统一的 CalendarProvider 接口

这样既满足你现在的需求（iCloud），
又为未来扩展留好了架构空间。

你觉得如何？
```

**对话长度：可能直接缩短 50%！**

---

### 5.2 假设我一开始就主动澄清

**场景重现：**

**你：**
```
我想集成系统日历和提醒事项
```

**我（优化后）：**
```
好的！在推荐方案之前，让我先了解一下：

关键问题：
1. 你现在用什么管理日历和待办？
   - Apple 日历 + 提醒？
   - Google Calendar？
   - 其他？

2. 你的数据存储在哪？
   - 本地？
   - iCloud？
   - Google？

3. 未来会在其他平台使用吗？
   - 只在 Mac？
   - 可能 Windows/Linux？

4. 能接受账号登录吗？
   - 可以 OAuth 登录？
   - 只想本地访问？

回答这些后，我能给你最合适的方案！
```

**结果：直接避免了后面的反复讨论！**

---

## 6. 具体建议

### 6.1 下次与 AI 讨论需求时

#### ✅ 好的提示词结构

```
第一段：简短描述项目
第二段：背景和当前状态
第三段：核心需求和原因
第四段：约束条件
第五段：技术偏好（如果有）
最后：具体问题
```

#### 示例

```
我想开发一个专注力提升应用，在下班后使用电脑时提醒我学习。

【背景】
我现在用 Apple 日历管理日程，Apple 提醒事项管理任务，
数据通过 iCloud 同步。主要在 Mac mini 上使用（24/7 开机），
也用 iPhone。未来可能换 Windows 电脑。

【核心需求】
1. 检测空闲时间后重新使用电脑
2. 弹出全屏提醒，读取今日日历和待办
3. 强制选择今晚要做什么
4. 记录统计数据

【约束】
✅ 可以联网、可以账号登录、可以学习新技术
⚠️ 希望支持多种日历服务（Apple、Google 等）
❌ 不能付费订阅第三方服务

【技术】
我会用 AI 辅助开发，复杂度不是问题。
在考虑 Tauri vs Swift 原生。

【问题】
1. 应该选择哪种技术栈？
2. 如何集成多种日历服务？
3. 有没有现成的库可以用？
```

---

### 6.2 实时对话技巧

#### 技巧 1：当 AI 做出假设时，立即纠正

```
AI: "推荐本地方案..."
你: "等等，我未来可能在 Windows 使用"
    ↓
AI 会立即调整方案
```

#### 技巧 2：主动补充关键信息

```
AI: "你需要设置目标吗？"
你: "需要，顺便说一下，我现在用 iCloud 日历，
     希望能读取今日事件"
    ↓
AI 获得了额外的关键信息
```

#### 技巧 3：质疑不合理的建议

```
AI: "云服务 API 不推荐"
你: "为什么？我觉得可以啊"
    ↓
AI 会重新评估
```

**你在这次对话中就做得很好！** 👏

---

### 6.3 使用结构化格式

#### YAML 格式（清晰）

```yaml
project: Focus Guardian
current_state:
  tools: [Apple Calendar, Apple Reminders]
  data_location: iCloud
  devices: [Mac mini, iPhone]
  future_devices: [Windows PC]
requirements:
  - idle_detection
  - calendar_integration
  - multi_service_support
constraints:
  acceptable:
    - network_required
    - oauth_login
  not_acceptable:
    - paid_api
priorities:
  must_have: [cross_platform]
  nice_to_have: [performance]
```

#### Markdown 表格（对比）

```markdown
| 维度 | 当前 | 期望 |
|:---|:---|:---|
| 平台 | macOS | macOS + Windows |
| 日历 | Apple | 多服务支持 |
| 数据 | iCloud | 保持不变或扩展 |
```

---

## 7. 元认知：这次对话的价值

### 你学到了什么？

1. ✅ **提示词重要性**：完整背景 > 简短描述
2. ✅ **澄清的价值**：质疑 AI 的假设
3. ✅ **渐进式讨论**：可以逐步深入
4. ✅ **AI 的局限**：不会读心，需要明确信息

### 我学到了什么？

1. ✅ **不要急于下结论**
2. ✅ **主动澄清关键信息**
3. ✅ **暴露自己的假设**
4. ✅ **提供多方案对比**

---

## 8. 通用提示词模板

### 模板 A：技术选型类问题

```markdown
# 技术选型咨询

## 项目简介
[一句话描述项目]

## 当前状态
- 使用的工具/服务：
- 数据存储位置：
- 技术栈：
- 团队规模：

## 核心需求
1. [需求] - 因为 [原因]
2. [需求] - 因为 [原因]

## 未来计划
- 用户规模：
- 平台扩展：
- 功能扩展：

## 约束条件
| 类型 | 条件 |
|:---|:---|
| ✅ 可以 | [列举] |
| ❌ 不可以 | [列举] |
| ⚠️ 不确定 | [列举] |

## 技术偏好
- 开发方式：[自己/团队/AI 辅助]
- 学习意愿：[高/中/低]
- 时间压力：[紧/松]

## 问题
我在考虑 [方案 A] vs [方案 B]，
从 [角度1]、[角度2]、[角度3] 来看，
你推荐哪个？为什么？
```

---

### 模板 B：需求讨论类问题

```markdown
# 需求讨论

## 背景
[描述现状和痛点]

## 目标
想要达到：[具体目标]
解决问题：[具体问题]

## 参考
类似产品：[举例]
喜欢的点：[列举]
不喜欢的点：[列举]

## 用户画像
- 主要用户：[描述]
- 使用场景：[描述]
- 使用频率：[描述]

## 开放性问题
- 我不确定：[列举不确定的点]
- 我想知道：[列举想了解的]
- 我担心：[列举担心的]

## 请你帮我
1. 梳理核心需求
2. 设计用户旅程
3. 评估技术可行性
```

---

### 模板 C：技术实现类问题

```markdown
# 技术实现咨询

## 要实现的功能
[具体描述]

## 当前技术栈
- 语言：
- 框架：
- 依赖：

## 已尝试的方案
1. [方案] - 结果：[成功/失败] - 原因：[...]
2. [方案] - 结果：[成功/失败] - 原因：[...]

## 具体问题
1. [问题] - 期望：[...]
2. [问题] - 期望：[...]

## 约束
- 性能要求：
- 兼容性要求：
- 其他限制：

## 请提供
- 实现思路
- 代码示例
- 潜在坑点
```

---

## 9. 总结

### 核心要点

| 要点 | 说明 |
|:---|:---|
| 🎯 **明确目标** | 说清楚"是什么"和"为什么" |
| 📦 **完整背景** | 当前状态、未来计划、约束条件 |
| 🔍 **暴露假设** | AI 和用户都要暴露自己的假设 |
| ❓ **主动澄清** | 不清楚就问，不要猜 |
| 🔄 **迭代讨论** | 可以质疑、纠正、深入 |

### 一句话总结

```
好的提示词 = 完整背景 + 明确约束 + 清晰优先级 + 具体问题
```

---

## 10. 下一步

现在我们已经梳理清楚了：

✅ **技术方案**：Tauri + iCloud CalDAV + 多服务扩展架构  
✅ **需求理解**：完整的 PRD  
✅ **协作方式**：优化后的提示词策略

**准备好开始下一步了吗？**

1. 细化技术架构设计
2. 设计数据模型
3. 编写 CalDAV 客户端
4. 实现 UI 原型

---

**你觉得这个分析有帮助吗？还有什么想深入讨论的？**